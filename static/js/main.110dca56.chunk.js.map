{"version":3,"sources":["logo.svg","SortingVisual/Bar.js","Algorithms/BubbleSort.js","Algorithms/InsertionSort.js","Algorithms/HeapSort.js","Algorithms/MergeSort.js","Algorithms/QuickSort.js","SortingVisual/SortingMain.js","Algorithms/BucketSort.js","Algorithms/RadixSort.js","Algorithms/ShellSort.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Bar","this","props","size","isDoneBeingSorted","isBeingCompared","index","isCurrentlyInCorrectOrder","showSize","extraClassName","className","id","Component","swap","arr","index1","index2","temp","insertionSort","animations","i","length","swapped","j","comparedElement","firstElement","firstElementHeight","secondElement","secondElementHeight","push","comparedElements","maxHeap","parent","max","leftChild","rightChild","compared","parentHeight","left","leftHeight","right","rightHeight","swappedLeft","mergeSort","secondArray","slice","executeMergeSort","mainArray","startIndex","endIndex","middleIndex","Math","floor","lower","insertionIndex","upper","objectsCompared","indexOne","indexTwo","indexSwap","value","mergeTwoArrays","quickSort","quickSortHelper","start","end","pivot","higher","pivotIndex","info","oldPivotIndexValue","SortingMain","componentDidUpdate","numElements","state","numberOfElements","totalWidth","window","screen","width","margin","element","document","getElementById","style","height","elementsToSort","handleRandomizeClick","gridBeingUsed","elements","loadArray","setState","elementsToSortSizes","elementSize","elementObjects","num","elementSizes","getRandomInt","createBar","handleNumElementChange","event","target","newElementsToSortSizes","newElementsToSortBars","updateCurrentAlgo","algorithm","currentAlgo","setBarBeingCompared","currentElements","setBarNotBeingCompared","changeBarSize","setMultipleBarsToBeingCompared","indexes","setMultipleBarToNotBeingCompared","updateSortSpeed","speed","speed_value_ms","sortSpeedSelected","currentSpeed","reset","setBarToDone","sortElements","checked","setTimeout","algo","animateBubbleSort","sorted","first","firstHeight","second","secondHeight","bubbleSort","animateBucketSort","originalArr","min","range","buckets","groupedArr","bucket","concat","bucketSort","animateHeapSort","last","lastHeight","heapSort","animateInsertionSort","animateMergeSort","animateQuickSort","animateRadixSort","place","maxNum","toString","getMax","positions","Array","from","newIndexes","newPosition","row","col","position","abs","pow","newIndex","undefined","currentIndex","z","radixSort","animateShellSort","gap","shellSort","changingNumberOfElements","opacity","stoppedChangingNumberOfElements","dropDownSpeedPressed","classList","toggle","dropDownAlgorithmsPressed","algorithms","sortSpeed","random","bars","animationDone","currentAnimation","current","original","grouped","nextTime","time1","newHeight","time2","type","for","class","onClick","disabled","onChange","onMouseDown","onMouseUp","map","bar","key","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.110dca56.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","import React, { Component } from \"react\";\r\nimport \"./Bar.css\";\r\n\r\nexport default class Bar extends Component {\r\n  render() {\r\n    const {\r\n      size,\r\n      isDoneBeingSorted,\r\n      isBeingCompared,\r\n      isCurrentlyInCorrectOrder,\r\n      index,\r\n      showSize,\r\n    } = this.props;\r\n\r\n    let extraClassName = \"\";\r\n    if (isDoneBeingSorted) {\r\n      extraClassName = \"doneElement\";\r\n    } else if (isBeingCompared) {\r\n      extraClassName = \"comparedElement\";\r\n    } else if (isCurrentlyInCorrectOrder) {\r\n    }\r\n    return (\r\n      <div className={`bar ${extraClassName}`} id={`Bar-${index}`}>\r\n        <text className={`${showSize ? \"size-text\" : \"hide-size\"}`}>\r\n          {size}\r\n        </text>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","/*\r\nBUBBLE SORT ALGORITHM.\r\n- best case: O(n)\r\n- worst case: O(n^2)\r\n- average: O(n^2)\r\nIterate through the array, swapping adjacent elements if they are in the wrong order, until the array\r\nis fully sorted.\r\n */\r\n\r\nexport function bubbleSort(arr) {\r\n  let animations = [];\r\n  let sorted = false;\r\n  // check if the array is fully sorted (if the algorithm makes a complete iteration\r\n  // without making any swaps)\r\n  while (!sorted) {\r\n    sorted = true;\r\n    // iterate through array\r\n    for (let i = 0; i < arr.length - 1; i++) {\r\n      // if two adjacent elements are out of order, swap them\r\n      if (arr[i] > arr[i + 1]) {\r\n        // store the two elements being compared if they are swapped (for animation purposes)\r\n        let comparedElements = {\r\n          first: i,\r\n          firstHeight: arr[i],\r\n          second: i + 1,\r\n          secondHeight: arr[i + 1],\r\n          swap: true,\r\n        };\r\n        animations.push(comparedElements);\r\n        // swap\r\n        swap(arr, i, i + 1);\r\n        sorted = false;\r\n      } else {\r\n        // store the two elements being compared if they are not swapped (for animation purposes)\r\n        let comparedElements = {\r\n          first: i,\r\n          second: i + 1,\r\n          swap: false,\r\n        };\r\n        animations.push(comparedElements);\r\n      }\r\n    }\r\n  }\r\n  return animations;\r\n}\r\n\r\n// helper method: swap the elements at the given indexes in the given array\r\nlet swap = (arr, index1, index2) => {\r\n  let temp = arr[index1];\r\n  arr[index1] = arr[index2];\r\n  arr[index2] = temp;\r\n};\r\n","// insertion sort runs in quadratic time. It works by comparing each element to the element before it,\r\n// swapping if the element before is smaller\r\n\r\nexport function insertionSort(arr) {\r\n  let animations = [];\r\n  for (let i = 1; i < arr.length; i++) {\r\n    // determines if two elements were swapped or not\r\n    let swapped = false;\r\n    let j = i;\r\n    while (j > 0 && arr[j - 1] > arr[j]) {\r\n      // indicate that elements were swapped\r\n      swapped = true;\r\n      let comparedElement = {\r\n        firstElement: j,\r\n        firstElementHeight: arr[j],\r\n        secondElement: j - 1,\r\n        secondElementHeight: arr[j - 1],\r\n        swap: true,\r\n      };\r\n      // push animation twice (we need to display color and then remove color)\r\n      animations.push(comparedElement);\r\n      animations.push(comparedElement);\r\n      // swap the two elements being compared\r\n      swap(arr, j, j - 1);\r\n      j--;\r\n    }\r\n    // if the elements were not swapped, indicate so\r\n    if (!swapped) {\r\n      let comparedElements = {\r\n        firstElement: i,\r\n        secondElement: j,\r\n        swap: false,\r\n      };\r\n      // push animation twice (we need to display color and then remove color)\r\n      animations.push(comparedElements);\r\n      animations.push(comparedElements);\r\n    }\r\n    swapped = false;\r\n  }\r\n  // return all the animations made in the runtime of algorithm\r\n  return animations;\r\n}\r\n\r\n// took code from bubble sort\r\nfunction swap(arr, index1, index2) {\r\n  let temp = arr[index1];\r\n  arr[index1] = arr[index2];\r\n  arr[index2] = temp;\r\n}\r\n","/*\r\nHEAP SORT ALGORITHM.\r\n- best case: O(nlog(n))\r\n- worst case: O(nlog(n))\r\n- average: O(nlog(n))\r\nCreate a max heap, swap the first and last elements, \"delete\" the last element, and then reform the max heap.\r\nRepeat until there are no more elements to sort.\r\n */\r\n\r\nexport function heapSort(arr) {\r\n  let animations = [];\r\n  // turn the array into a max heap\r\n  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\r\n    maxHeap(arr, i, arr.length - 1, animations);\r\n  }\r\n  // swap first and last element\r\n  // \"delete\" last element by decrementing the size\r\n  // fix the remaining heap so it is a max heap again\r\n  let size = arr.length - 1;\r\n  for (let i = size; i > 0; i--) {\r\n    let compared = {\r\n      maxHeap: false,\r\n      first: 0,\r\n      firstHeight: arr[0],\r\n      last: i,\r\n      lastHeight: arr[i],\r\n    };\r\n    animations.push(compared);\r\n    swap(arr, 0, i);\r\n    size--;\r\n    maxHeap(arr, 0, size, animations);\r\n  }\r\n  return animations;\r\n}\r\n\r\n// create a max heap\r\nlet maxHeap = (arr, parent, size, animations) => {\r\n  // low = index of parent node\r\n  let leftChild = 2 * parent;\r\n  let rightChild = 2 * parent + 1;\r\n\r\n  // figure out max (the index of the maximum value between the parent and children nodes)\r\n  let max;\r\n  if (leftChild <= size && arr[leftChild] > arr[parent]) {\r\n    max = leftChild;\r\n  } else {\r\n    max = parent;\r\n  }\r\n  if (rightChild <= size && arr[rightChild] > arr[max]) {\r\n    max = rightChild;\r\n  }\r\n\r\n  // if max is not the parent:\r\n  // swap the parent and child so the parent now holds a greater value than its children\r\n  // keep figuring out the max heap with the new parent node\r\n  if (max !== parent) {\r\n    // store parent/child information if either child is greater than the parent (for animation purposes)\r\n    let compared = {\r\n      maxHeap: true,\r\n      parent: parent,\r\n      parentHeight: arr[parent],\r\n      left: leftChild,\r\n      leftHeight: arr[leftChild],\r\n      right: rightChild,\r\n      rightHeight: arr[rightChild],\r\n      swapped: true,\r\n      swappedLeft: false,\r\n    };\r\n    if (max === leftChild) {\r\n      compared.swappedLeft = true;\r\n    }\r\n    animations.push(compared);\r\n    // swap parent and child\r\n    swap(arr, parent, max);\r\n    // check if it is now a max heap\r\n    maxHeap(arr, max, size, animations);\r\n  } else if (leftChild <= size && rightChild <= size) {\r\n    // store parent/child information if the parent is greater than its children (for animation purposes)\r\n    let compared = {\r\n      maxHeap: true,\r\n      parent: parent,\r\n      left: leftChild,\r\n      right: rightChild,\r\n      swapped: false,\r\n    };\r\n    animations.push(compared);\r\n  }\r\n};\r\n\r\n// helper method: swap the elements at the given indexes in the given array\r\nlet swap = (arr, index1, index2) => {\r\n  let temp = arr[index1];\r\n  arr[index1] = arr[index2];\r\n  arr[index2] = temp;\r\n};\r\n","// Merge Sort. Merge sort is a divide and conquer way of sorting an array.\r\n// It works by splitting an array down to smaller arrays, sorting the smaller arrays,\r\n// then merging sorted arrays together. Its time complexity is O(nlog(n))\r\n\r\nexport function mergeSort(arr) {\r\n  const secondArray = arr.slice();\r\n  const animations = [];\r\n  executeMergeSort(arr, secondArray, 0, arr.length - 1, animations);\r\n  return animations;\r\n}\r\n\r\nfunction executeMergeSort(\r\n  mainArray,\r\n  secondArray,\r\n  startIndex,\r\n  endIndex,\r\n  animations\r\n) {\r\n  if (startIndex !== endIndex) {\r\n    let middleIndex = Math.floor((startIndex + endIndex) / 2);\r\n    executeMergeSort(\r\n      secondArray,\r\n      mainArray,\r\n      startIndex,\r\n      middleIndex,\r\n      animations\r\n    );\r\n    executeMergeSort(\r\n      secondArray,\r\n      mainArray,\r\n      middleIndex + 1,\r\n      endIndex,\r\n      animations\r\n    );\r\n    mergeTwoArrays(\r\n      mainArray,\r\n      secondArray,\r\n      startIndex,\r\n      middleIndex,\r\n      endIndex,\r\n      animations\r\n    );\r\n  }\r\n}\r\n\r\nfunction mergeTwoArrays(\r\n  mainArray,\r\n  secondArray,\r\n  startIndex,\r\n  middleIndex,\r\n  endIndex,\r\n  animations\r\n) {\r\n  let lower = startIndex;\r\n  let insertionIndex = startIndex;\r\n  let upper = middleIndex + 1;\r\n\r\n  while (lower <= middleIndex && upper <= endIndex) {\r\n    let objectsCompared = {\r\n      indexOne: lower,\r\n      indexTwo: upper,\r\n    };\r\n    animations.push(objectsCompared);\r\n    animations.push(objectsCompared);\r\n\r\n    if (secondArray[lower] > secondArray[upper]) {\r\n      animations.push({ indexSwap: insertionIndex, value: secondArray[upper] });\r\n      mainArray[insertionIndex] = secondArray[upper];\r\n      insertionIndex++;\r\n      upper++;\r\n    } else {\r\n      animations.push({ indexSwap: insertionIndex, value: secondArray[lower] });\r\n      mainArray[insertionIndex] = secondArray[lower];\r\n      insertionIndex++;\r\n      lower++;\r\n    }\r\n  }\r\n\r\n  while (lower <= middleIndex) {\r\n    let objectsCompared = {\r\n      indexOne: lower,\r\n      indexTwo: lower,\r\n    };\r\n    animations.push(objectsCompared);\r\n    animations.push(objectsCompared);\r\n    animations.push({ indexSwap: insertionIndex, value: secondArray[lower] });\r\n    mainArray[insertionIndex] = secondArray[lower];\r\n    insertionIndex++;\r\n    lower++;\r\n  }\r\n\r\n  while (upper <= endIndex) {\r\n    let objectsCompared = {\r\n      indexOne: upper,\r\n      indexTwo: upper,\r\n    };\r\n    animations.push(objectsCompared);\r\n    animations.push(objectsCompared);\r\n    animations.push({ indexSwap: insertionIndex, value: secondArray[upper] });\r\n    mainArray[insertionIndex] = secondArray[upper];\r\n    insertionIndex++;\r\n    upper++;\r\n  }\r\n}\r\n","/*\r\nQUICK SORT ALGORITHM.\r\n- best case: O(nlog(n))\r\n- worse case: O(n^2)\r\n- average: O(nlog(n))\r\nIf x is the pivot: put x at its correct spot in the array, put smaller elements\r\nbefore x and greater elements after x. Sort left and right sides recursively.\r\n */\r\n\r\nexport function quickSort(arr) {\r\n  let animations = [];\r\n  quickSortHelper(arr, animations, 0, arr.length - 1);\r\n  return animations;\r\n}\r\n\r\n// partitions the array between the given start and end indexes. chooses a pivot and rearranges the array so the\r\n// elements on the left side of the pivot are less than the pivot and the elements on the right side are greater\r\n// than or equal to the pivot. continues to partition sections of the array until it is sorted.\r\nfunction quickSortHelper(arr, animations, start, end) {\r\n  // choose a pivot\r\n  let pivot = arr[start];\r\n  // all the elements lower than the pivot\r\n  let lower = [];\r\n  // all the elements greater than the pivot\r\n  let higher = [];\r\n\r\n  // partition the elements (less than the pivot -> lower, greater than or equal to the pivot -> higher)\r\n  for (let i = start + 1; i <= end; i++) {\r\n    if (arr[i] < pivot) {\r\n      lower.push(arr[i]);\r\n    } else {\r\n      higher.push(arr[i]);\r\n    }\r\n  }\r\n\r\n  // the correct index of the pivot\r\n  let pivotIndex = start + lower.length;\r\n\r\n  // store information about the pivot and lower/higher elements (for animation purposes)\r\n  let info = {\r\n    start: start,\r\n    end: end,\r\n    pivot: pivot,\r\n    pivotIndex: pivotIndex,\r\n    oldPivotIndexValue: arr[pivotIndex],\r\n    lower: lower,\r\n    higher: higher,\r\n  };\r\n  animations.push(info);\r\n\r\n  // rearrange array so the elements less than the pivot are on the left side, the pivot is in the\r\n  // correct location, and the elements greater than or equal to the pivot are on the right side\r\n  for (let i = start; i < pivotIndex; i++) {\r\n    arr[i] = lower[i - start];\r\n  }\r\n  arr[pivotIndex] = pivot;\r\n  for (let i = pivotIndex + 1; i <= end; i++) {\r\n    arr[i] = higher[i - pivotIndex - 1];\r\n  }\r\n\r\n  // as long as there is more than one element, partition the left and right sides of the pivot\r\n  if (lower.length > 1) {\r\n    quickSortHelper(arr, animations, start, pivotIndex - 1);\r\n  }\r\n  if (higher.length > 1) {\r\n    quickSortHelper(arr, animations, pivotIndex + 1, end);\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./SortingMain.css\";\r\nimport Bar from \"./Bar\";\r\nimport { bubbleSort } from \"../Algorithms/BubbleSort\";\r\nimport { bucketSort } from \"../Algorithms/BucketSort\";\r\nimport { heapSort } from \"../Algorithms/HeapSort\";\r\nimport { insertionSort } from \"../Algorithms/InsertionSort\";\r\nimport { mergeSort } from \"../Algorithms/MergeSort\";\r\nimport { quickSort } from \"../Algorithms/QuickSort\";\r\nimport { radixSort } from \"../Algorithms/RadixSort\";\r\nimport { shellSort } from \"../Algorithms/ShellSort\";\r\n\r\nexport default class SortingMain extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      currentAlgo: \"Algorithms\",\r\n      algorithms: [],\r\n      elementsToSort: [],\r\n      elementsToSortSizes: [],\r\n      numberOfElements: 50,\r\n      sortSpeed: [\"Slow\", \"Regular\", \"Fast\"],\r\n      sortSpeedSelected: \"Sorting Speed\",\r\n      currentSpeed: 0,\r\n      gridBeingUsed: false,\r\n    };\r\n  }\r\n\r\n  // returns a random number between 1 and max, inclusive\r\n  getRandomInt(max) {\r\n    return Math.floor(Math.random() * Math.floor(max) + 1);\r\n  }\r\n\r\n  // updates width, height, and margin of bars depending on how many there are\r\n  componentDidUpdate = () => {\r\n    // width of screen\r\n    let numElements = this.state.numberOfElements;\r\n    let totalWidth = window.screen.width;\r\n    // calculate margin between bars\r\n    let margin = numElements <= 40 ? 8 : 5;\r\n    // calculate width of one bar\r\n    let width = numElements <= 26 ? 30 : totalWidth / numElements - margin - 10;\r\n    if (numElements > 70) {\r\n      width = 3;\r\n    }\r\n    // update bars\r\n    for (let i = 0; i < numElements; i++) {\r\n      let element = document.getElementById(\"Bar-\" + i);\r\n      element.style.height = this.state.elementsToSort[i].size * 8 + \"px\";\r\n      element.style.width = width + \"px\";\r\n      element.style.margin = margin + \"px\";\r\n    }\r\n  };\r\n\r\n  componentDidMount() {\r\n    // initialize elements\r\n    let algos = [\r\n      \"Merge Sort\",\r\n      \"Quick Sort\",\r\n      \"Insertion Sort\",\r\n      \"Bubble Sort\",\r\n      \"Shell Sort\",\r\n      \"Heap Sort\",\r\n      \"Radix Sort\",\r\n      \"Bucket Sort\",\r\n    ];\r\n    let bars = this.loadArray(this.state.numberOfElements);\r\n    this.setState({\r\n      algorithms: algos,\r\n      elementsToSort: bars.elementObjects,\r\n      elementsToSortSizes: bars.elementSize,\r\n    });\r\n  }\r\n\r\n  // randomizes the values of the bars (elements to be sorted)\r\n  handleRandomizeClick = () => {\r\n    // randomize elements\r\n    if (!this.state.gridBeingUsed) {\r\n      let elements = this.loadArray();\r\n      this.setState({\r\n        elementsToSortSizes: elements.elementSize,\r\n        elementsToSort: elements.elementObjects,\r\n      });\r\n    }\r\n  };\r\n\r\n  // initialize values of bars (elements to be sorted) to the given number of random values\r\n  loadArray = (num) => {\r\n    let elementObjects = [];\r\n    let elementSizes = [];\r\n    let size = num ? num : this.state.numberOfElements;\r\n    for (let i = 0; i < size; i++) {\r\n      let num = this.getRandomInt(60);\r\n      elementSizes.push(num);\r\n      elementObjects.push(this.createBar(num));\r\n    }\r\n    return { elementObjects: elementObjects, elementSize: elementSizes };\r\n  };\r\n\r\n  createBar = (size) => {\r\n    return {\r\n      size: size,\r\n      isDoneBeingSorted: false,\r\n      isBeingCompared: false,\r\n      isCurrentlyInCorrectOrder: false,\r\n    };\r\n  };\r\n\r\n  // changes the number of elements to be sorted\r\n  handleNumElementChange = (event) => {\r\n    // set the number of elements in the array to the value on slider\r\n    let numElements = event.target.value;\r\n    let newElementsToSortSizes = [];\r\n    let newElementsToSortBars = [];\r\n    for (let i = 0; i < numElements; i++) {\r\n      let num = this.getRandomInt(60);\r\n      newElementsToSortSizes.push(num);\r\n      newElementsToSortBars.push(this.createBar(num));\r\n    }\r\n    this.setState({\r\n      numberOfElements: numElements,\r\n      elementsToSort: newElementsToSortBars,\r\n      elementsToSortSizes: newElementsToSortSizes,\r\n    });\r\n  };\r\n\r\n  // updates the selected sorting algorithm\r\n  updateCurrentAlgo = (algorithm) => {\r\n    // set the current algo selected\r\n    this.setState({\r\n      currentAlgo: algorithm,\r\n    });\r\n  };\r\n\r\n  setBarBeingCompared = (index) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    currentElements[index].isBeingCompared = true;\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  setBarNotBeingCompared = (index) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    currentElements[index].isBeingCompared = false;\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  changeBarSize = (index, size) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    currentElements[index].size = size;\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  // animate the merge sort algorithm\r\n  animateMergeSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    // the index that the set timeout will be relative to\r\n    for (let i = 0; i <= length; i++) {\r\n      // if we have reached the end of the animations, display ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        let currentAnimation = animations[i];\r\n        // if we do not need to merge, we should only animate the two bars we are comparing\r\n        if (i % 3 === 0) {\r\n          setTimeout(() => {\r\n            this.setBarBeingCompared(currentAnimation.indexOne);\r\n            this.setBarBeingCompared(currentAnimation.indexTwo);\r\n          }, i * currentSpeed);\r\n        } else if (i % 3 == 1) {\r\n          // this is the second time we have seen the animation, so remove the color from bars\r\n          setTimeout(() => {\r\n            this.setBarNotBeingCompared(currentAnimation.indexOne);\r\n            this.setBarNotBeingCompared(currentAnimation.indexTwo);\r\n          }, i * currentSpeed);\r\n        } else {\r\n          setTimeout(() => {\r\n            this.changeBarSize(\r\n              currentAnimation.indexSwap,\r\n              currentAnimation.value\r\n            );\r\n          }, i * currentSpeed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the radix sort algorithm\r\n  animateRadixSort(animations, currentSpeed) {\r\n    // get the number of animations\r\n    let length = animations.length;\r\n    for (let i = 0; i <= length; i++) {\r\n      // if we have reached the end of the animations, display the ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        // get the current animation\r\n        let currentAnimation = animations[i];\r\n        // if it an even index, it is the first time we have seen the animation, color the bar in appopriately\r\n        if (i % 2 === 0) {\r\n          setTimeout(() => {\r\n            this.setBarBeingCompared(currentAnimation.index);\r\n          }, i * currentSpeed);\r\n        } else {\r\n          // take color out of bar and set its height appropriately\r\n          setTimeout(() => {\r\n            this.setBarNotBeingCompared(currentAnimation.index);\r\n            this.changeBarSize(currentAnimation.index, currentAnimation.height);\r\n          }, i * currentSpeed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the shell sort algorithm\r\n  animateShellSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    for (let i = 0; i <= length; i++) {\r\n      // if we have reached the end of the animations, display the ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        let currentAnimation = animations[i];\r\n        // if the index is even, it is the first time we have seen the animation, color in the\r\n        // bars being compared\r\n        if (i % 2 === 0) {\r\n          setTimeout(() => {\r\n            this.setBarBeingCompared(currentAnimation.firstElement);\r\n            this.setBarBeingCompared(currentAnimation.secondElement);\r\n          }, i * currentSpeed);\r\n        } else {\r\n          // take colors out of bars and set the height of bar appropriately\r\n          setTimeout(() => {\r\n            this.setBarNotBeingCompared(currentAnimation.firstElement);\r\n            this.setBarNotBeingCompared(currentAnimation.secondElement);\r\n            this.changeBarSize(\r\n              currentAnimation.firstElement,\r\n              currentAnimation.secondElementHeight\r\n            );\r\n          }, i * currentSpeed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the insertion sort algorithm\r\n  animateInsertionSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    for (let i = 0; i <= length; i++) {\r\n      // if we have reached the end of the animations, display the ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        let currentAnimation = animations[i];\r\n        // if the index is even, it is the first time we have seen the animation, color in the\r\n        // bars being compared\r\n        if (i % 2 === 0) {\r\n          setTimeout(() => {\r\n            this.setBarBeingCompared(currentAnimation.firstElement);\r\n            this.setBarBeingCompared(currentAnimation.secondElement);\r\n          }, i * currentSpeed);\r\n        } else {\r\n          if (!currentAnimation.swap) {\r\n            // if the bars have not been swapped, remove the color\r\n            setTimeout(() => {\r\n              this.setBarNotBeingCompared(currentAnimation.firstElement);\r\n              this.setBarNotBeingCompared(currentAnimation.secondElement);\r\n            }, i * currentSpeed);\r\n          } else {\r\n            // if bars have been swapped, take colors out of bars and set the height of bars appropriately\r\n            setTimeout(() => {\r\n              this.setBarNotBeingCompared(currentAnimation.firstElement);\r\n              this.setBarNotBeingCompared(currentAnimation.secondElement);\r\n              this.changeBarSize(\r\n                currentAnimation.firstElement,\r\n                currentAnimation.secondElementHeight\r\n              );\r\n              this.changeBarSize(\r\n                currentAnimation.secondElement,\r\n                currentAnimation.firstElementHeight\r\n              );\r\n            }, i * currentSpeed);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the bubble sort algorithm\r\n  animateBubbleSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    for (let i = 0; i <= length; i++) {\r\n      // display ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        let current = animations[i];\r\n        // add color to the two bars being compared\r\n        setTimeout(() => {\r\n          this.setBarBeingCompared(current.first);\r\n          this.setBarBeingCompared(current.second);\r\n        }, i * currentSpeed);\r\n        if (!current.swap) {\r\n          // if they are not swapped, remove color\r\n          setTimeout(() => {\r\n            this.setBarNotBeingCompared(current.first);\r\n            this.setBarNotBeingCompared(current.second);\r\n          }, (i + 1) * currentSpeed);\r\n        } else {\r\n          // if they are swapped, remove color and swap their heights\r\n          setTimeout(() => {\r\n            this.setBarNotBeingCompared(current.first);\r\n            this.setBarNotBeingCompared(current.second);\r\n            this.changeBarSize(current.first, current.secondHeight);\r\n            this.changeBarSize(current.second, current.firstHeight);\r\n          }, (i + 1) * currentSpeed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the bucket sort algorithm\r\n  animateBucketSort(animations, currentSpeed) {\r\n    // the original array\r\n    let original = animations[0];\r\n    // the array after being grouped into buckets\r\n    let grouped = animations[1];\r\n    // iterate through the original array\r\n    for (let j = 0; j < original.length; j++) {\r\n      setTimeout(() => {\r\n        this.setBarBeingCompared(j);\r\n      }, j * currentSpeed);\r\n      setTimeout(() => {\r\n        this.setBarNotBeingCompared(j);\r\n      }, (j + 1) * currentSpeed);\r\n    }\r\n    // group the array into buckets\r\n    setTimeout(() => {\r\n      for (let j = 0; j < grouped.length; j++) {\r\n        // add color\r\n        setTimeout(() => {\r\n          this.setBarBeingCompared(j);\r\n        }, j * currentSpeed);\r\n        // remove color and change height\r\n        setTimeout(() => {\r\n          this.setBarNotBeingCompared(j);\r\n          this.changeBarSize(j, grouped[j]);\r\n        }, (j + 1) * currentSpeed);\r\n      }\r\n    }, original.length * currentSpeed);\r\n    // insertion sort the grouped array\r\n    setTimeout(() => {\r\n      this.animateInsertionSort(insertionSort(grouped), currentSpeed);\r\n    }, original.length * 2 * currentSpeed);\r\n  }\r\n\r\n  // If we use setState to change the color of every bar individually, there will be lag with the heap sort algorithm.\r\n  setMultipleBarsToBeingCompared = (indexes) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      if (currentElements[indexes[i]]) {\r\n        currentElements[indexes[i]].isBeingCompared = true;\r\n      }\r\n    }\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  // If we use setState to change the color of every bar individually, there will be lag with the heap sort algorithm.\r\n  setMultipleBarToNotBeingCompared = (index) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    for (let i = 0; i < index.length; i++) {\r\n      if (currentElements[index[i]]) {\r\n        currentElements[index[i]].isBeingCompared = false;\r\n      }\r\n    }\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  // animate the heap sort algorithm\r\n  animateHeapSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    for (let i = 0; i <= length; i++) {\r\n      // display ending animation\r\n      if (i === length) {\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, i * currentSpeed);\r\n      } else {\r\n        let current = animations[i];\r\n        if (current.maxHeap) {\r\n          // building a max heap\r\n          // add color to the parent and children elements\r\n\r\n          setTimeout(() => {\r\n            this.setMultipleBarsToBeingCompared([\r\n              current.parent,\r\n              current.left,\r\n              current.right,\r\n            ]);\r\n          }, i * currentSpeed);\r\n          if (current.swapped) {\r\n            // if two elements need to be swapped, remove color and swap the two elements\r\n            if (current.swappedLeft) {\r\n              // swap parent with left child\r\n              setTimeout(() => {\r\n                this.setMultipleBarToNotBeingCompared([\r\n                  current.parent,\r\n                  current.left,\r\n                  current.right,\r\n                ]);\r\n                this.changeBarSize(current.parent, current.leftHeight);\r\n                this.changeBarSize(current.left, current.parentHeight);\r\n              }, (i + 1) * currentSpeed);\r\n            } else {\r\n              // swap parent with right child\r\n              setTimeout(() => {\r\n                this.setMultipleBarToNotBeingCompared([\r\n                  current.left,\r\n                  current.parent,\r\n                  current.right,\r\n                ]);\r\n                this.changeBarSize(current.parent, current.rightHeight);\r\n                this.changeBarSize(current.right, current.parentHeight);\r\n              }, (i + 1) * currentSpeed);\r\n            }\r\n          } else {\r\n            // if nothing needs to be swapped, remove color\r\n            setTimeout(() => {\r\n              this.setMultipleBarToNotBeingCompared([\r\n                current.left,\r\n                current.parent,\r\n                current.right,\r\n              ]);\r\n            }, (i + 1) * currentSpeed);\r\n          }\r\n        } else {\r\n          // if it is already a max heap, swap first and last elements\r\n          // add color to first and last elements\r\n          setTimeout(() => {\r\n            this.setMultipleBarsToBeingCompared([current.first, current.last]);\r\n          }, i * currentSpeed);\r\n          // remove color and swap first and last elements\r\n          setTimeout(() => {\r\n            this.setMultipleBarToNotBeingCompared([\r\n              current.first,\r\n              current.last,\r\n            ]);\r\n            this.changeBarSize(current.first, current.lastHeight);\r\n            this.changeBarSize(current.last, current.firstHeight);\r\n          }, (i + 1) * currentSpeed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // animate the quick sort algorithm\r\n  animateQuickSort(animations, currentSpeed) {\r\n    let length = animations.length;\r\n    let nextTime = 0;\r\n    for (let i = 0; i <= length; i++) {\r\n      if (i === length) {\r\n        // display ending animation\r\n        setTimeout(() => {\r\n          this.animationDone();\r\n        }, (i + nextTime) * currentSpeed);\r\n      } else {\r\n        let current = animations[i];\r\n        // move pivot to correct location\r\n        // add color to pivot\r\n        setTimeout(() => {\r\n          this.setBarBeingCompared(current.start);\r\n          this.setBarBeingCompared(current.pivotIndex);\r\n        }, (i + nextTime) * currentSpeed);\r\n        // remove color to pivot and swap places with the bar at its correct location\r\n        setTimeout(() => {\r\n          this.setBarNotBeingCompared(current.start);\r\n          this.setBarNotBeingCompared(current.pivotIndex);\r\n          this.changeBarSize(current.start, current.oldPivotIndexValue);\r\n          this.changeBarSize(current.pivotIndex, current.pivot);\r\n        }, (i + nextTime + 1) * currentSpeed);\r\n\r\n        // partition the rest of the elements around the pivot\r\n        setTimeout(() => {\r\n          // move all the elements less than the pivot to the left side\r\n          let time1 = 0;\r\n          for (let j = current.start; j < current.pivotIndex; j++) {\r\n            setTimeout(() => {\r\n              this.setBarBeingCompared(j);\r\n            }, time1 * currentSpeed);\r\n            let newHeight = current.lower[j - current.start];\r\n            setTimeout(() => {\r\n              this.setBarNotBeingCompared(j);\r\n              this.changeBarSize(j, newHeight);\r\n            }, (time1 + 1) * currentSpeed);\r\n            time1++;\r\n          }\r\n          // move all the elements greater than the pivot to the right side\r\n          let time2 = 0;\r\n          for (let j = current.end; j >= current.pivotIndex + 1; j--) {\r\n            setTimeout(() => {\r\n              this.setBarBeingCompared(j);\r\n            }, time2 * currentSpeed);\r\n            let newHeight = current.higher[j - current.pivotIndex - 1];\r\n            setTimeout(() => {\r\n              this.setBarNotBeingCompared(j);\r\n              this.changeBarSize(j, newHeight);\r\n            }, (time2 + 1) * currentSpeed);\r\n            time2++;\r\n          }\r\n        }, (i + nextTime + 1) * currentSpeed);\r\n        nextTime =\r\n          3 + nextTime + Math.max(current.lower.length, current.higher.length);\r\n      }\r\n    }\r\n  }\r\n\r\n  // determines how fast the sorting algorithms are running\r\n  updateSortSpeed = (speed) => {\r\n    // fast = 5, medium = 15, slow = 100\r\n    let speed_value_ms;\r\n    if (speed === \"Slow\") {\r\n      speed_value_ms = 100;\r\n    } else if (speed === \"Regular\") {\r\n      speed_value_ms = 30;\r\n    } else {\r\n      speed_value_ms = 20;\r\n    }\r\n    this.setState({\r\n      sortSpeedSelected: speed,\r\n      currentSpeed: speed_value_ms,\r\n    });\r\n  };\r\n\r\n  // reset all elements to initial state\r\n  reset = () => {\r\n    if (!this.state.gridBeingUsed) {\r\n      let elements = this.loadArray(50);\r\n      this.setState({\r\n        numberOfElements: 50,\r\n        elementsToSortSizes: elements.elementSize,\r\n        currentAlgo: \"Algorithms\",\r\n        sortSpeedSelected: \"Sorting Speed\",\r\n        currentSpeed: 0,\r\n        elementsToSort: elements.elementObjects,\r\n      });\r\n    }\r\n  };\r\n\r\n  setBarToDone = (index) => {\r\n    let currentElements = this.state.elementsToSort.slice();\r\n    currentElements[index].isDoneBeingSorted = true;\r\n    this.setState({\r\n      elementsToSort: currentElements,\r\n    });\r\n  };\r\n\r\n  // this animation happens when algorithms are done\r\n  animationDone() {\r\n    for (let i = 0; i <= this.state.numberOfElements; i++) {\r\n      if (i < this.state.numberOfElements) {\r\n        setTimeout(() => {\r\n          this.setBarToDone(i);\r\n        }, i * this.state.currentSpeed);\r\n      } else {\r\n        setTimeout(() => {\r\n          let currentElements = this.state.elementsToSort.slice();\r\n          for (let i = 0; i < currentElements.length; i++) {\r\n            currentElements[i].isDoneBeingSorted = false;\r\n          }\r\n          this.setState({\r\n            elementsToSort: currentElements,\r\n            gridBeingUsed: false,\r\n          });\r\n        }, i * this.state.currentSpeed + 1000);\r\n      }\r\n    }\r\n  }\r\n\r\n  // sorts the elements using the current selected algorithm\r\n  sortElements = () => {\r\n    document.getElementById(\"check\").checked = false;\r\n    if (\r\n      !this.state.gridBeingUsed &&\r\n      this.state.currentAlgo !== \"Algorithms\" &&\r\n      this.state.sortSpeedSelected !== \"Sorting Speed\"\r\n    ) {\r\n      this.setState({\r\n        gridBeingUsed: true,\r\n      });\r\n      setTimeout(() => {\r\n        let currentSpeed = this.state.currentSpeed;\r\n        let elements = this.state.elementsToSortSizes;\r\n        let algo = this.state.currentAlgo;\r\n        if (algo === \"Bubble Sort\") {\r\n          this.animateBubbleSort(bubbleSort(elements), currentSpeed);\r\n        } else if (algo === \"Bucket Sort\") {\r\n          this.animateBucketSort(bucketSort(elements), currentSpeed);\r\n        } else if (algo === \"Heap Sort\") {\r\n          this.animateHeapSort(heapSort(elements), currentSpeed);\r\n        } else if (algo === \"Insertion Sort\") {\r\n          this.animateInsertionSort(insertionSort(elements), currentSpeed);\r\n        } else if (algo === \"Merge Sort\") {\r\n          this.animateMergeSort(mergeSort(elements), currentSpeed);\r\n        } else if (algo === \"Quick Sort\") {\r\n          this.animateQuickSort(quickSort(elements), currentSpeed);\r\n        } else if (algo === \"Radix Sort\") {\r\n          this.animateRadixSort(radixSort(elements), currentSpeed);\r\n        } else if (algo === \"Shell Sort\") {\r\n          this.animateShellSort(shellSort(elements), currentSpeed);\r\n        }\r\n      }, 600);\r\n    }\r\n  };\r\n\r\n  changingNumberOfElements = () => {\r\n    let sidebar = document.getElementById(\"left-sidebar\");\r\n    sidebar.style.opacity = 0.5;\r\n  };\r\n\r\n  stoppedChangingNumberOfElements = () => {\r\n    let sidebar = document.getElementById(\"left-sidebar\");\r\n    sidebar.style.opacity = 1;\r\n  };\r\n\r\n  dropDownSpeedPressed = () => {\r\n    if (!this.state.gridBeingUsed) {\r\n      document\r\n        .getElementById(\"speed-options\")\r\n        .classList.toggle(\"speed-options-show\");\r\n    }\r\n  };\r\n\r\n  dropDownAlgorithmsPressed = () => {\r\n    if (!this.state.gridBeingUsed) {\r\n      document\r\n        .getElementById(\"algorithm-options\")\r\n        .classList.toggle(\"algorithm-options-show\");\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"page\">\r\n        <input type=\"checkbox\" id=\"check\" />\r\n        <label for=\"check\">\r\n          <i class=\"fas fa-bars\" id=\"btn\"></i>\r\n          <i class=\"fas fa-times\" id=\"cancel\"></i>\r\n        </label>\r\n        <div class=\"sidebar\" id=\"left-sidebar\">\r\n          <header>Options</header>\r\n          <ul>\r\n            <li\r\n              onClick={this.dropDownAlgorithmsPressed}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              <a\r\n                class={`${\r\n                  this.state.gridBeingUsed\r\n                    ? \"drop-down-algo-running\"\r\n                    : \"drop-down\"\r\n                }`}\r\n              >\r\n                {this.state.currentAlgo}\r\n                <span class=\"fa fa-caret-right expand caret\"></span>\r\n              </a>\r\n              <ul id=\"algorithm-options\" class=\"speed-options-dont-show\">\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Merge Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Merge Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Quick Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Quick Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Insertion Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Insertion Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Bubble Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Bubble Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Shell Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Shell Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Heap Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Heap Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Radix Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Radix Sort</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateCurrentAlgo(\"Bucket Sort\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Bucket Sort</a>\r\n                </li>\r\n              </ul>\r\n            </li>\r\n\r\n            <li\r\n              onClick={this.dropDownSpeedPressed}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              <a\r\n                class={`${\r\n                  this.state.gridBeingUsed\r\n                    ? \"drop-down-algo-running\"\r\n                    : \"drop-down\"\r\n                }`}\r\n              >\r\n                {this.state.sortSpeedSelected}\r\n                <span class=\"fa fa-caret-right expand caret\"></span>\r\n              </a>\r\n\r\n              <ul id=\"speed-options\" class=\"speed-options-dont-show\">\r\n                <li class=\"item\" onClick={() => this.updateSortSpeed(\"Slow\")}>\r\n                  <a class=\"drop-down-option\">Slow</a>\r\n                </li>\r\n                <li\r\n                  class=\"item\"\r\n                  onClick={() => this.updateSortSpeed(\"Regular\")}\r\n                >\r\n                  <a class=\"drop-down-option\">Regular</a>\r\n                </li>\r\n                <li class=\"item\" onClick={() => this.updateSortSpeed(\"Fast\")}>\r\n                  <a class=\"drop-down-option\">Fast</a>\r\n                </li>\r\n              </ul>\r\n            </li>\r\n\r\n            <li\r\n              class={\r\n                this.state.gridBeingUsed ? \"button-algo-running\" : \"button\"\r\n              }\r\n              onClick={this.handleRandomizeClick}\r\n            >\r\n              <a>Randomize Elements</a>\r\n            </li>\r\n            <li\r\n              class={\r\n                this.state.gridBeingUsed ? \"button-algo-running\" : \"button\"\r\n              }\r\n              onClick={this.reset}\r\n            >\r\n              <a>Reset</a>\r\n            </li>\r\n            <li>\r\n              <a>\r\n                <input\r\n                  id=\"sliderNumElements\"\r\n                  type=\"range\"\r\n                  min=\"2\"\r\n                  max=\"96\"\r\n                  className=\"slider\"\r\n                  value={this.state.numberOfElements}\r\n                  onChange={this.handleNumElementChange}\r\n                  onMouseDown={this.changingNumberOfElements}\r\n                  onMouseUp={this.stoppedChangingNumberOfElements}\r\n                  disabled={this.state.gridBeingUsed ? true : false}\r\n                />\r\n                <label className=\"minorLabel\">\r\n                  {this.state.numberOfElements}\r\n                </label>\r\n              </a>\r\n            </li>\r\n            <li\r\n              onClick={this.sortElements}\r\n              class={\r\n                this.state.gridBeingUsed ||\r\n                this.state.currentAlgo === \"Algorithms\" ||\r\n                this.state.sortSpeedSelected === \"Sorting Speed\"\r\n                  ? \"button-algo-running\"\r\n                  : \"start-button\"\r\n              }\r\n            >\r\n              <a>Start</a>\r\n            </li>\r\n          </ul>\r\n        </div>\r\n        <div className=\"top-banner\">\r\n          <h1 className=\"header\">Sorting algorithm visualizer</h1>\r\n        </div>\r\n        <div className=\"bars\">\r\n          {this.state.elementsToSort.map((bar, index) => {\r\n            const {\r\n              size,\r\n              isDoneBeingSorted,\r\n              isBeingCompared,\r\n              isCurrentlyInCorrectOrder,\r\n            } = bar;\r\n            return (\r\n              <Bar\r\n                size={size}\r\n                isBeingCompared={isBeingCompared}\r\n                isDoneBeingSorted={isDoneBeingSorted}\r\n                isCurrentlyInCorrectOrder={isCurrentlyInCorrectOrder}\r\n                key={index}\r\n                index={index}\r\n                showSize={this.state.numberOfElements <= 25}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n/*\r\n        <div className=\"footer\">\r\n          <label className=\"label\">Number of elements:</label>\r\n          <input\r\n            id=\"sliderNumElements\"\r\n            type=\"range\"\r\n            min=\"2\"\r\n            max=\"96\"\r\n            className=\"slider\"\r\n            value={this.state.numberOfElements}\r\n            onChange={this.handleNumElementChange}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          />\r\n          <label className=\"minorLabel\">{this.state.numberOfElements}</label>\r\n          <button\r\n            id=\"buttonRandomize\"\r\n            className=\"button\"\r\n            onClick={this.handleRandomizeClick}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          >\r\n            Randomize Elements\r\n          </button>\r\n          <label className=\"label\">Sort with: </label>\r\n          <select\r\n            id=\"sliderAlgo\"\r\n            className=\"dropDown\"\r\n            value={this.state.currentAlgo}\r\n            onChange={this.updateCurrentAlgo}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          >\r\n            {this.state.algorithms.map((algorithms) => (\r\n              <option key={algorithms} value={algorithms}>\r\n                {algorithms}\r\n              </option>\r\n            ))}\r\n          </select>\r\n          <label className=\"label\">Sorting speed:</label>\r\n          <select\r\n            id=\"sliderAlgoSpeed\"\r\n            className=\"dropDownSpeed\"\r\n            value={this.state.sortSpeedSelected}\r\n            onChange={this.updateSortSpeed}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          >\r\n            {this.state.sortSpeed.map((element) => (\r\n              <option key={element} value={element}>\r\n                {element}\r\n              </option>\r\n            ))}\r\n          </select>\r\n          <button\r\n            id=\"buttonVisualize\"\r\n            className=\"button\"\r\n            onClick={this.sortElements}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          >\r\n            VISUALIZE SORTING\r\n          </button>\r\n          <button\r\n            id=\"buttonReset\"\r\n            className=\"button\"\r\n            onClick={this.reset}\r\n            disabled={this.state.gridBeingUsed ? true : false}\r\n          >\r\n            Reset\r\n          </button>\r\n        </div>\r\n\r\n\r\n        CSS:\r\n\r\n        .button {\r\n  border-radius: 8px;\r\n  background: whitesmoke;\r\n  border: 2px solid darkslategray;\r\n  color: darkslategray;\r\n  padding: 10px;\r\n  margin-left: 15px;\r\n  font-size: 14px;\r\n  outline: none;\r\n  font-weight: bold;\r\n}\r\n\r\n.button:hover {\r\n  background: lavender;\r\n}\r\n\r\n.dropDownSpeed {\r\n  border: 2px solid darkslategray;\r\n  height: 42px;\r\n  width: 7%;\r\n  margin-left: 10px;\r\n  outline: none;\r\n  font-size: 14px;\r\n  color: darkslategray;\r\n  font-weight: bold;\r\n}\r\n\r\n.dropDownSpeed:hover {\r\n  background: lavender;\r\n}\r\n\r\n.dropDown {\r\n  border: 2px solid darkslategray;\r\n  height: 42px;\r\n  width: 10%;\r\n  margin-left: 10px;\r\n  outline: none;\r\n  font-size: 14px;\r\n  color: darkslategray;\r\n  font-weight: bold;\r\n}\r\n\r\n.dropDown:hover {\r\n  background: lavender;\r\n}\r\n\r\n.footer {\r\n  position: fixed;\r\n  bottom: 0;\r\n  display: inline-block;\r\n  width: 100%;\r\n  height: 90px;\r\n  background-color: whitesmoke;\r\n  text-align: center;\r\n}\r\n\r\n\r\n.label {\r\n  text-align: center;\r\n  font-weight: bold;\r\n  color: darkslategray;\r\n  line-height: 90px;\r\n  margin-left: 15px;\r\n}\r\n    */\r\n","/*\r\nBUCKET SORT ALGORITHM.\r\n- best case: O(n+k)\r\n- worst case: O(n^2)\r\n- average: O(n+k)\r\nSeparate the elements of the array into \"buckets\" that hold a specific range\r\nof values. Individually sort the buckets using insertion sort, then recombine them.\r\n */\r\n\r\nimport { insertionSort } from \"./InsertionSort\";\r\n\r\nexport function bucketSort(arr) {\r\n  let animations = [];\r\n  // make a copy of original array (for animation purposes)\r\n  let originalArr = arr.slice();\r\n  animations.push(originalArr);\r\n\r\n  // default bucket size\r\n  const BUCKET_SIZE = 5;\r\n  // find min and max values in array\r\n  let min = arr[0];\r\n  let max = arr[0];\r\n  for (let i = 1; i < arr.length; i++) {\r\n    if (arr[i] < min) {\r\n      min = arr[i];\r\n    }\r\n    if (arr[i] > max) {\r\n      max = arr[i];\r\n    }\r\n  }\r\n  // create buckets of size 5\r\n  let range = max - min;\r\n  let buckets = [];\r\n  for (let i = 0; i <= Math.floor(range / BUCKET_SIZE); i++) {\r\n    buckets.push([]);\r\n  }\r\n  // add values to buckets\r\n  for (let value of arr) {\r\n    buckets[Math.floor((value - min) / BUCKET_SIZE)].push(value);\r\n  }\r\n\r\n  // group the buckets together in order (for animation purposes)\r\n  let groupedArr = [];\r\n  for (let bucket of buckets) {\r\n    groupedArr = groupedArr.concat(bucket);\r\n  }\r\n  animations.push(groupedArr);\r\n\r\n  // sort each bucket and recombine them\r\n  arr = [];\r\n  for (let bucket of buckets) {\r\n    if (bucket.length > 1) {\r\n      insertionSort(bucket);\r\n    }\r\n    if (bucket.length > 0) {\r\n      arr = arr.concat(bucket);\r\n    }\r\n  }\r\n  return animations;\r\n}\r\n","// radix sort sorts the array based on the value of each digit in each index of the array. It uses counting sort\r\n// to do this, stopping when it reaches the number of digits in the largest array\r\n\r\n// radix sort\r\nexport function radixSort(arr) {\r\n  // get the maximum number of digits\r\n  let maxNum = getMax(arr);\r\n\r\n  let positions = [];\r\n\r\n  // for every digit:\r\n  // note: Radix sort works because the elements in the original array are changing every\r\n  //       iteration. This, combined with the fact that counting sort is stable, results in the correct\r\n  //       ending array\r\n  for (let i = 0; i < maxNum; i++) {\r\n    // create 10 empty arrays\r\n    let buckets = Array.from({ length: 10 }, () => []);\r\n\r\n    // tracks the new index of every element\r\n    let newIndexes = [];\r\n\r\n    // for every number in the array:\r\n    for (let j = 0; j < arr.length; j++) {\r\n      let newPosition = {\r\n        height: arr[j],\r\n        index: j,\r\n        row: null,\r\n        col: null,\r\n      };\r\n      positions.push(newPosition);\r\n      positions.push(newPosition);\r\n      // get the digit at the ith place in every element\r\n      let position = getPosition(arr[j], i);\r\n\r\n      // push the new position of the first element so that\r\n      // it can be animated first (animation will look cooler)\r\n\r\n      // at this point, we dont know what the actual index of this element is,\r\n      // we will need to calculate it after the loop terminates\r\n      let newIndex = {\r\n        height: arr[j],\r\n        index: undefined,\r\n        row: position,\r\n        col: buckets[position].length,\r\n      };\r\n      newIndexes.push(newIndex);\r\n\r\n      // push the element into the correct spot in the 10 arrays stored in bucket\r\n      buckets[position].push(arr[j]);\r\n    }\r\n\r\n    // calculate how many elements come before the position of an index\r\n    for (let i = 0; i < newIndexes.length; i++) {\r\n      let currentIndex = newIndexes[i];\r\n      let newIndex = 0;\r\n      for (let j = 0; j <= currentIndex.row; j++) {\r\n        for (let z = 0; z < buckets[j].length; z++) {\r\n          if (j === currentIndex.row && z === currentIndex.col) {\r\n            break;\r\n          }\r\n          newIndex++;\r\n        }\r\n      }\r\n      currentIndex.index = newIndex;\r\n    }\r\n\r\n    // push the elements in newIndexes to be displated in the positions array\r\n    for (let i = 0; i < newIndexes.length; i++) {\r\n      // push animation twice (we need to display color and then remove color)\r\n      positions.push(newIndexes[i]);\r\n      positions.push(newIndexes[i]);\r\n    }\r\n\r\n    // set array equal to the non empty elements in buckets in the order they appear\r\n    arr = [].concat(...buckets);\r\n  }\r\n  return positions;\r\n}\r\n\r\n// get the maximum number of digits in a number\r\nfunction getMax(arr) {\r\n  let max = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let num = arr[i];\r\n    if (max < num.toString().length) {\r\n      max = num.toString().length;\r\n    }\r\n  }\r\n  return max;\r\n}\r\n\r\n// get the digit at a position in a number ( getPosition(231,1) = 3)\r\nfunction getPosition(num, place) {\r\n  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;\r\n}\r\n","// shell sort is an extended version of insertion sort, where a particular\r\n// element in an array is not being compared to the elements next to it but a certain\r\n// gap distance away\r\n\r\nexport function shellSort(arr) {\r\n  // if there is only one element, the array is sorted\r\n  if (arr.length === 1) {\r\n    return arr;\r\n  }\r\n\r\n  // animations to be returned\r\n  let animations = [];\r\n\r\n  // get the length of the array\r\n  let length = arr.length;\r\n  // the gap is first set to half the length of the array\r\n  let gap = Math.floor(length / 2);\r\n\r\n  // while the gap is not zero\r\n  while (gap > 0) {\r\n    // go through every element starting at the gap index\r\n    for (let i = gap; i < arr.length; i++) {\r\n      // temp variable that is swapped later\r\n      let temp = arr[i];\r\n      // refers to the index of element swapped\r\n      let last = i;\r\n\r\n      // if the element to the left of j that is gap distance away is greater than the current element\r\n      for (let j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\r\n        let comparedElements = {\r\n          firstElement: j,\r\n          secondElement: j - gap,\r\n          secondElementHeight: arr[j - gap],\r\n          firstElementHeight: arr[j],\r\n        };\r\n        animations.push(comparedElements);\r\n        animations.push(comparedElements);\r\n        // set the jth element to be the j - gap element\r\n        arr[j] = arr[j - gap];\r\n        last -= gap;\r\n      }\r\n      let comparedElements = {\r\n        firstElement: last,\r\n        secondElement: i,\r\n        secondElementHeight: temp,\r\n        firstElementHeight: arr[last],\r\n      };\r\n      // push animation twice (we need to display color and then remove color)\r\n      animations.push(comparedElements);\r\n      animations.push(comparedElements);\r\n      arr[last] = temp;\r\n    }\r\n    // gap is cut in half each time (eventually becoming insertion sort when it is 1)\r\n    gap = Math.floor(gap / 2);\r\n  }\r\n\r\n  return animations;\r\n}\r\n","import React from \"react\";\r\nimport logo from \"./logo.svg\";\r\nimport \"./App.css\";\r\nimport SortingMain from \"./SortingVisual/SortingMain\";\r\n\r\nfunction App() {\r\n  return <SortingMain />;\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}