{"version":3,"sources":["logo.svg","SortingVisual/Bar.js","Algorithms/BubbleSort.js","Algorithms/InsertionSort.js","Algorithms/HeapSort.js","Algorithms/MergeSort.js","Algorithms/QuickSort.js","SortingVisual/SortingMain.js","Algorithms/BucketSort.js","Algorithms/RadixSort.js","Algorithms/ShellSort.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Bar","props","state","value","size","className","id","this","index","Component","swap","arr","index1","index2","temp","insertionSort","animations","i","length","swapped","j","comparedElement","firstElement","firstElementHeight","secondElement","secondElementHeight","push","comparedElements","maxHeap","parent","max","leftChild","rightChild","compared","parentHeight","left","leftHeight","right","rightHeight","swappedLeft","mergeSort","m","merge","Math","min","mergesort","arr1","startIndexLeft","endIndexLeft","startIndexRight","endIndexRight","mergedArray","subArrayOne","subArrayTwo","slice","indexCompareOne","indexCompareTwo","objectsCompared","indexOne","indexTwo","end","shift","startIndex","endIndex","mergedarray","z","quickSort","quickSortHelper","start","pivot","lower","higher","pivotIndex","info","oldPivotIndexValue","SortingMain","componentDidUpdate","numElements","numberOfElements","totalWidth","window","screen","width","margin","element","document","getElementById","style","height","elementsToSort","handleRandomizeClick","elements","loadArray","setState","numBars","num","getRandomInt","handleNumElementChange","event","target","newElementsToSort","updateCurrentAlgo","currentAlgo","sortElements","currentSpeed","algo","disableElements","animateBubbleSort","sorted","first","firstHeight","second","secondHeight","bubbleSort","animateBucketSort","originalArr","range","buckets","floor","groupedArr","bucket","concat","bucketSort","animateHeapSort","last","lastHeight","heapSort","animateInsertionSort","animateMergeSort","animateQuickSort","animateRadixSort","place","maxNum","toString","getMax","positions","Array","from","newIndexes","newPosition","row","col","position","abs","pow","newIndex","undefined","currentIndex","radixSort","animateShellSort","gap","shellSort","updateSortSpeed","speed","sortSpeedSelected","reset","algorithms","sortSpeed","random","time","setTimeout","animationDone","currentAnimation","mergeIndex","animateMerging","animateComparison","indexStart","indexEnd","indexInLoop","classList","add","remove","current","original","grouped","nextTime","time1","newHeight","time2","enableElements","setAttribute","removeAttribute","map","n","key","type","onChange","onClick","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.97dae2af.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","import React, {Component} from 'react'\r\nimport './Bar.css';\r\n\r\nexport default class Bar extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.size\r\n        };\r\n    }\r\n    render() {\r\n        return (\r\n        <div className=\"bar\" id={`Bar-${this.props.index}`}>\r\n            <div className=\"placeholderElement\">\r\n                {this.props.size}\r\n            </div>\r\n        </div>\r\n        );\r\n    }\r\n}","/*\r\nBUBBLE SORT ALGORITHM.\r\n- best case: O(n)\r\n- worst case: O(n^2)\r\n- average: O(n^2)\r\nIterate through the array, swapping adjacent elements if they are in the wrong order, until the array\r\nis fully sorted.\r\n */\r\n\r\nexport function bubbleSort(arr) {\r\n    let animations = [];\r\n    let sorted = false;\r\n    // check if the array is fully sorted (if the algorithm makes a complete iteration\r\n    // without making any swaps)\r\n    while (!sorted) {\r\n        sorted = true;\r\n        // iterate through array\r\n        for (let i = 0; i < arr.length - 1; i++) {\r\n            // if two adjacent elements are out of order, swap them\r\n            if (arr[i] > arr[i + 1]) {\r\n                // store the two elements being compared if they are swapped (for animation purposes)\r\n                let comparedElements = {\r\n                    first: i,\r\n                    firstHeight: arr[i],\r\n                    second: i + 1,\r\n                    secondHeight: arr[i + 1],\r\n                    swap: true\r\n                };\r\n                animations.push(comparedElements);\r\n                // swap\r\n                swap(arr, i, i + 1);\r\n                sorted = false;\r\n            } else {\r\n                // store the two elements being compared if they are not swapped (for animation purposes)\r\n                let comparedElements = {\r\n                    first: i,\r\n                    second: i + 1,\r\n                    swap: false\r\n                };\r\n                animations.push(comparedElements);\r\n            }\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\n// helper method: swap the elements at the given indexes in the given array\r\nlet swap = (arr, index1, index2) => {\r\n    let temp = arr[index1];\r\n    arr[index1] = arr[index2];\r\n    arr[index2] = temp;\r\n};","// insertion sort runs in quadratic time. It works by comparing each element to the element before it,\r\n// swapping if the element before is smaller\r\n\r\nexport function insertionSort(arr) {\r\n    let animations = [];\r\n    for(let i = 1; i < arr.length; i++) {\r\n        // determines if two elements were swapped or not\r\n        let swapped = false;\r\n        let j = i;\r\n        while(j > 0 && (arr[j-1] > arr[j])) {\r\n            // indicate that elements were swapped\r\n            swapped = true;\r\n            let comparedElement = {\r\n                firstElement: j,\r\n                firstElementHeight: arr[j],\r\n                secondElement: j - 1,\r\n                secondElementHeight: arr[j - 1],\r\n                swap: true\r\n            }\r\n            // push animation twice (we need to display color and then remove color)\r\n            animations.push(comparedElement);\r\n            animations.push(comparedElement);\r\n            // swap the two elements being compared\r\n            swap(arr,j,j-1);\r\n            j--;                    \r\n        }\r\n        // if the elements were not swapped, indicate so\r\n        if(!swapped) {\r\n            let comparedElements = {\r\n                firstElement: i,\r\n                secondElement: j,\r\n                swap: false\r\n            }\r\n            // push animation twice (we need to display color and then remove color)\r\n            animations.push(comparedElements);\r\n            animations.push(comparedElements);\r\n        }\r\n        swapped = false;\r\n    }\r\n    // return all the animations made in the runtime of algorithm\r\n    return animations;\r\n}\r\n\r\n// took code from bubble sort\r\nfunction swap(arr, index1, index2) {\r\n    let temp = arr[index1];\r\n    arr[index1] = arr[index2];\r\n    arr[index2] = temp;\r\n}","/*\r\nHEAP SORT ALGORITHM.\r\n- best case: O(nlog(n))\r\n- worst case: O(nlog(n))\r\n- average: O(nlog(n))\r\nCreate a max heap, swap the first and last elements, \"delete\" the last element, and then reform the max heap.\r\nRepeat until there are no more elements to sort.\r\n */\r\n\r\nexport function heapSort(arr) {\r\n    let animations = [];\r\n    // turn the array into a max heap\r\n    for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\r\n        maxHeap(arr, i, arr.length - 1, animations);\r\n    }\r\n    // swap first and last element\r\n    // \"delete\" last element by decrementing the size\r\n    // fix the remaining heap so it is a max heap again\r\n    let size = arr.length - 1;\r\n    for (let i = size; i > 0; i--) {\r\n        let compared = {\r\n            maxHeap: false,\r\n            first: 0,\r\n            firstHeight: arr[0],\r\n            last: i,\r\n            lastHeight: arr[i],\r\n        };\r\n        animations.push(compared);\r\n        swap(arr, 0, i);\r\n        size--;\r\n        maxHeap(arr, 0, size, animations);\r\n    }\r\n    return animations;\r\n}\r\n\r\n// create a max heap\r\nlet maxHeap = (arr, parent, size, animations) => {\r\n    // low = index of parent node\r\n    let leftChild = 2 * parent;\r\n    let rightChild = 2 * parent + 1;\r\n\r\n    // figure out max (the index of the maximum value between the parent and children nodes)\r\n    let max;\r\n    if (leftChild <= size && arr[leftChild] > arr[parent]) {\r\n        max = leftChild;\r\n    } else {\r\n        max = parent;\r\n    }\r\n    if (rightChild <= size && arr[rightChild] > arr[max]) {\r\n        max = rightChild;\r\n    }\r\n\r\n    // if max is not the parent:\r\n    // swap the parent and child so the parent now holds a greater value than its children\r\n    // keep figuring out the max heap with the new parent node\r\n    if (max !== parent) {\r\n        // store parent/child information if either child is greater than the parent (for animation purposes)\r\n        let compared = {\r\n            maxHeap: true,\r\n            parent: parent,\r\n            parentHeight: arr[parent],\r\n            left: leftChild,\r\n            leftHeight: arr[leftChild],\r\n            right: rightChild,\r\n            rightHeight: arr[rightChild],\r\n            swapped: true,\r\n            swappedLeft: false\r\n        };\r\n        if (max === leftChild) {\r\n            compared.swappedLeft = true;\r\n        }\r\n        animations.push(compared);\r\n        // swap parent and child\r\n        swap(arr, parent, max);\r\n        // check if it is now a max heap\r\n        maxHeap(arr, max, size, animations);\r\n    } else if (leftChild <= size && rightChild <= size) {\r\n        // store parent/child information if the parent is greater than its children (for animation purposes)\r\n        let compared = {\r\n            maxHeap: true,\r\n            parent: parent,\r\n            left: leftChild,\r\n            right: rightChild,\r\n            swapped: false\r\n        };\r\n        animations.push(compared);\r\n    }\r\n};\r\n\r\n// helper method: swap the elements at the given indexes in the given array\r\nlet swap = (arr, index1, index2) => {\r\n    let temp = arr[index1];\r\n    arr[index1] = arr[index2];\r\n    arr[index2] = temp;\r\n};","// Merge Sort. Merge sort is a divide and conquer way of sorting an array.\r\n// It work by splitting an array down to smaller arrays, sorting the smaller arrays,\r\n// then merging sorted arrays together. Its time complexity is O(nlog(n))\r\n\r\nexport function mergeSort(arr) {\r\n    let animations = mergesort(arr);\r\n    return animations;\r\n}\r\n\r\nfunction mergesort(arr) {\r\n    let animations = [];\r\n    let length = arr.length;\r\n    let m = 1;\r\n    // non recursive implementaton of merge sort\r\n    while(m < length) {\r\n        let i = 0;\r\n        while(i < (length - m)) {\r\n            // merge two arrays together\r\n            merge(arr,i,i + m - 1, i + m, Math.min(i + (2*m) - 1, length - 1), animations);\r\n            i = i + (2 * m);\r\n        }\r\n        m *= 2;\r\n    }\r\n    return animations;\r\n    \r\n}\r\n\r\n// merge two arrays together\r\nfunction merge(arr1, startIndexLeft,endIndexLeft,startIndexRight,endIndexRight,animations) {\r\n    let mergedArray = [];   // represents the merged product of the two arrays\r\n    // make a copy of array given\r\n    let subArrayOne = [...arr1];\r\n    let subArrayTwo = [...arr1];\r\n    // split arrays based on index given\r\n    subArrayOne = subArrayOne.slice(startIndexLeft, endIndexLeft + 1);\r\n    subArrayTwo = subArrayTwo.slice(startIndexRight,endIndexRight + 1);\r\n\r\n    // index being compared\r\n    let indexCompareOne = startIndexLeft;\r\n    let indexCompareTwo = startIndexRight\r\n\r\n    // add the smallest element in both arrays to the end of 'mergedArray'\r\n    // this guarantees that mergedArray is sorted\r\n    while(subArrayOne.length !== 0 && subArrayTwo.length !== 0) {\r\n        let objectsCompared = {\r\n            indexOne : indexCompareOne,\r\n            indexTwo : indexCompareTwo,\r\n            end: false\r\n        }\r\n        // push animation twice (we need to display color and then remove color)\r\n        animations.push(objectsCompared);\r\n        animations.push(objectsCompared);\r\n        if(subArrayOne[0] > subArrayTwo[0]) {\r\n            mergedArray.push(subArrayTwo[0]);\r\n            subArrayTwo.shift();\r\n            indexCompareTwo++;\r\n        } else {\r\n            mergedArray.push(subArrayOne[0]);\r\n            subArrayOne.shift();\r\n            indexCompareOne++;\r\n        }\r\n    }\r\n\r\n    // at this point, either arr1 is empty or arr2 is empty.\r\n    // add all elements of unempty array to the end of the sorted array\r\n    while(subArrayOne.length !== 0) {\r\n        mergedArray.push(subArrayOne[0]);\r\n        subArrayOne.shift();\r\n        indexCompareOne++;\r\n        let objectsCompared = {\r\n            indexOne: indexCompareOne,\r\n            indexTwo: indexCompareTwo,\r\n            end:false\r\n        }\r\n        // push animation twice (we need to display color and then remove color)\r\n        animations.push(objectsCompared);\r\n        animations.push(objectsCompared);\r\n    }\r\n    while(subArrayTwo.length !== 0) {\r\n        mergedArray.push(subArrayTwo[0]);\r\n        subArrayTwo.shift();\r\n        indexCompareTwo++;\r\n        let objectsCompared = {\r\n            indexOne: indexCompareOne,\r\n            indexTwo: indexCompareTwo,\r\n            end:false\r\n        }\r\n        // push animation twice (we need to display color and then remove color)\r\n        animations.push(objectsCompared);    \r\n        animations.push(objectsCompared); \r\n    }\r\n\r\n    // at this point we need to identify that the comparisons have been made and the array is read to merge\r\n    // therefore set 'end' to true\r\n    let objectsCompared = {\r\n        startIndex: startIndexLeft,\r\n        endIndex: endIndexRight + 1,\r\n        end: true,\r\n        mergedarray: mergedArray\r\n    }\r\n    // push animation twice (we need to display color and then remove color)\r\n    animations.push(objectsCompared);\r\n    animations.push(objectsCompared);\r\n    \r\n    // modify the array by overwriting merged values with the merged array\r\n    let z = 0;\r\n    for(let i = startIndexLeft; i < endIndexRight + 1; i++) {\r\n        arr1[i] = mergedArray[z];\r\n        z++;\r\n    }\r\n}","/*\r\nQUICK SORT ALGORITHM.\r\n- best case: O(nlog(n))\r\n- worse case: O(n^2)\r\n- average: O(nlog(n))\r\nIf x is the pivot: put x at its correct spot in the array, put smaller elements\r\nbefore x and greater elements after x. Sort left and right sides recursively.\r\n */\r\n\r\nexport function quickSort(arr) {\r\n    let animations = [];\r\n    quickSortHelper(arr, animations, 0, arr.length - 1);\r\n    return animations;\r\n}\r\n\r\n// partitions the array between the given start and end indexes. chooses a pivot and rearranges the array so the\r\n// elements on the left side of the pivot are less than the pivot and the elements on the right side are greater\r\n// than or equal to the pivot. continues to partition sections of the array until it is sorted.\r\nfunction quickSortHelper(arr, animations, start, end) {\r\n    // choose a pivot\r\n    let pivot = arr[start];\r\n    // all the elements lower than the pivot\r\n    let lower = [];\r\n    // all the elements greater than the pivot\r\n    let higher = [];\r\n\r\n    // partition the elements (less than the pivot -> lower, greater than or equal to the pivot -> higher)\r\n    for (let i = start + 1; i <= end; i++) {\r\n        if (arr[i] < pivot) {\r\n            lower.push(arr[i]);\r\n        } else {\r\n            higher.push(arr[i]);\r\n        }\r\n    }\r\n\r\n    // the correct index of the pivot\r\n    let pivotIndex = start + lower.length;\r\n\r\n    // store information about the pivot and lower/higher elements (for animation purposes)\r\n    let info = {\r\n        start: start,\r\n        end: end,\r\n        pivot: pivot,\r\n        pivotIndex: pivotIndex,\r\n        oldPivotIndexValue: arr[pivotIndex],\r\n        lower: lower,\r\n        higher: higher\r\n    };\r\n    animations.push(info);\r\n\r\n    // rearrange array so the elements less than the pivot are on the left side, the pivot is in the\r\n    // correct location, and the elements greater than or equal to the pivot are on the right side\r\n    for (let i = start; i < pivotIndex; i++) {\r\n        arr[i] = lower[i - start];\r\n    }\r\n    arr[pivotIndex] = pivot;\r\n    for (let i = pivotIndex + 1; i <= end; i++) {\r\n        arr[i] = higher[i - pivotIndex - 1];\r\n    }\r\n\r\n    // as long as there is more than one element, partition the left and right sides of the pivot\r\n    if (lower.length > 1) {\r\n        quickSortHelper(arr, animations, start, pivotIndex - 1);\r\n    }\r\n    if (higher.length > 1) {\r\n        quickSortHelper(arr, animations, pivotIndex + 1, end);\r\n    }\r\n}","import React, {Component} from 'react'\r\nimport './SortingMain.css';\r\nimport Bar from './Bar';\r\nimport {bubbleSort} from '../Algorithms/BubbleSort';\r\nimport {bucketSort} from '../Algorithms/BucketSort';\r\nimport {heapSort} from '../Algorithms/HeapSort';\r\nimport {insertionSort} from '../Algorithms/InsertionSort';\r\nimport {mergeSort} from '../Algorithms/MergeSort';\r\nimport {quickSort} from '../Algorithms/QuickSort';\r\nimport {radixSort} from '../Algorithms/RadixSort';\r\nimport {shellSort} from '../Algorithms/ShellSort';\r\n\r\nlet gridClear = true;\r\n\r\nexport default class SortingMain extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            currentAlgo: \"Merge Sort\",\r\n            algorithms: [],\r\n            elementsToSort: [],\r\n            numberOfElements: 50,\r\n            sortSpeed: [\"Slow\",\"Regular\",\"Fast\"],\r\n            sortSpeedSelected: \"Regular\",\r\n            currentSpeed: 15\r\n        }\r\n    };\r\n\r\n    // returns a random number between 1 and max, inclusive\r\n    getRandomInt(max) {\r\n        return Math.floor(Math.random() * Math.floor(max) + 1);\r\n    };\r\n\r\n    // updates width, height, and margin of bars depending on how many there are\r\n    componentDidUpdate = () => {\r\n        // width of screen\r\n        let numElements = this.state.numberOfElements;\r\n        let totalWidth = window.screen.width;\r\n        // calculate margin between bars\r\n        let margin = (numElements <= 40) ? 8 : 5;\r\n        // calculate width of one bar\r\n        let width = (numElements <= 26) ? 30 : (totalWidth / numElements) - margin - 10;\r\n        if (numElements > 70) {\r\n            width = 3;\r\n        }\r\n        // update bars\r\n        for (let i = 0; i < numElements; i++) {\r\n            let element = document.getElementById(\"Bar-\" + i);\r\n            element.style.height = this.state.elementsToSort[i] * 8 + \"px\";\r\n            element.style.width = width + \"px\";\r\n            element.style.margin = margin + \"px\";\r\n        }\r\n    };\r\n\r\n    componentDidMount() {\r\n        // initialize elements\r\n        let algos = [\"Merge Sort\", \"Quick Sort\", \"Insertion Sort\", \"Bubble Sort\",\"Shell Sort\",\r\n                    \"Heap Sort\",\"Radix Sort\",\"Bucket Sort\"];\r\n        let elements = this.loadArray(this.state.numberOfElements);\r\n        this.setState({\r\n            algorithms: algos,\r\n            elementsToSort: elements\r\n        });\r\n    };\r\n\r\n    // randomizes the values of the bars (elements to be sorted)\r\n    handleRandomizeClick = () => {\r\n        // randomize elements\r\n        let elements = this.loadArray(this.state.numberOfElements);\r\n        this.setState({\r\n            elementsToSort: elements\r\n        });\r\n    };\r\n\r\n    // initialize values of bars (elements to be sorted) to the given number of random values\r\n    loadArray = (numBars) => {\r\n        let elements = [];\r\n        for(let i = 0; i < numBars; i++) {\r\n            let num = this.getRandomInt(50);\r\n            elements.push(num);\r\n        }\r\n        return elements;\r\n    };\r\n\r\n    // changes the number of elements to be sorted\r\n    handleNumElementChange = (event) => {\r\n        // set the number of elements in the array to the value on slider\r\n        let numElements = event.target.value;\r\n        let newElementsToSort = [];\r\n        for (let i = 0; i < numElements; i++) {\r\n            newElementsToSort.push(this.getRandomInt(50));\r\n        }\r\n        this.setState({\r\n            numberOfElements: numElements,\r\n            elementsToSort: newElementsToSort\r\n        });\r\n    };\r\n\r\n    // updates the selected sorting algorithm\r\n    updateCurrentAlgo = (event) => {\r\n        // set the current algo selected\r\n        this.setState({\r\n            currentAlgo: event.target.value\r\n        });\r\n    };\r\n\r\n    // sorts the elements using the current selected algorithm\r\n    sortElements = () => {\r\n        gridClear = false;\r\n        let currentSpeed = this.state.currentSpeed;\r\n        let elements = this.state.elementsToSort;\r\n        let algo = this.state.currentAlgo;\r\n        this.disableElements();\r\n        if (algo === \"Bubble Sort\") {\r\n            this.animateBubbleSort(bubbleSort(elements), currentSpeed);\r\n        } else if (algo === \"Bucket Sort\") {\r\n            this.animateBucketSort(bucketSort(elements), currentSpeed);\r\n        } else if (algo === \"Heap Sort\") {\r\n            this.animateHeapSort(heapSort(elements), currentSpeed);\r\n        } else if (algo === \"Insertion Sort\") {\r\n            this.animateInsertionSort(insertionSort(elements), currentSpeed);\r\n        } else if (algo === \"Merge Sort\") {\r\n            this.animateMergeSort(mergeSort(elements), currentSpeed);\r\n        } else if (algo === \"Quick Sort\") {\r\n            this.animateQuickSort(quickSort(elements), currentSpeed);\r\n        } else if (algo === \"Radix Sort\") {\r\n            this.animateRadixSort(radixSort(elements), currentSpeed);\r\n        } else if (algo === \"Shell Sort\") {\r\n            this.animateShellSort(shellSort(elements), currentSpeed);\r\n        }\r\n    };\r\n\r\n    // animate the merge sort algorithm\r\n    animateMergeSort(animations,currentSpeed) {\r\n        let length = animations.length;\r\n        // the index that the set timeout will be relative to\r\n        let time = 0;\r\n        for(let i = 0; i <= length; i++) {\r\n            // if we have reached the end of the animations, display ending animation\r\n            if(i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, time * currentSpeed)\r\n            } else {\r\n                // get the current animation to be displayed\r\n                let currentAnimation = animations[i];\r\n                // if the animation's end property is true, we know that we need to animate a merge\r\n                if(currentAnimation.end) {\r\n                    let mergeIndex = 0;\r\n                    // manipulate bars at index 'startIndex' to index 'endIndex\r\n                    for(let j = currentAnimation.startIndex; j < currentAnimation.endIndex; j++) {\r\n                        // get the merged array\r\n                        let mergedArray = currentAnimation.mergedarray;\r\n                        // animate the merged array\r\n                        this.animateMerging(time,j,mergedArray[mergeIndex],currentSpeed,i);\r\n                        // increment the time of setTimout\r\n                        mergeIndex++;\r\n                        time++\r\n                    }\r\n                } else {\r\n                    // if we do not need to merge, we should only animate the two bars we are comparing\r\n                    this.animateComparison(time, currentAnimation.indexOne, currentAnimation.indexTwo - 1, i,currentSpeed);\r\n                }\r\n                time++;\r\n            }\r\n        }\r\n    };\r\n\r\n    // animate a comparison between two bars in the array\r\n    animateComparison(time, indexStart,indexEnd, indexInLoop,currentSpeed) {\r\n        // if the index is even, we know that it is the first time we are seeing this animation,\r\n        // thus only color the two bars in red\r\n        if(indexInLoop % 2 === 0) {\r\n            setTimeout(()=> {\r\n                document.getElementById(\"Bar-\" + indexStart).classList.add(\"comparedElement\");\r\n                document.getElementById(\"Bar-\" + indexEnd).classList.add(\"comparedElement\");\r\n            }, time * currentSpeed);\r\n        } else {\r\n            // this is the second time we have seen the animation, so remove the color from bars\r\n            setTimeout(()=> {\r\n                document.getElementById(\"Bar-\" + indexStart).classList.remove(\"comparedElement\");\r\n                document.getElementById(\"Bar-\" + indexEnd).classList.remove(\"comparedElement\");\r\n            }, time * currentSpeed);\r\n        }\r\n    };\r\n\r\n    // animate a merge between a set of bars in the array\r\n    animateMerging(time,index,height,currentSpeed,indexInLoop) {\r\n        // if the index is even, it is the first time we have encountered this merge\r\n        // color all of the bars to merge in red\r\n        if(indexInLoop % 2 === 0) {\r\n            setTimeout(()=> {\r\n                document.getElementById(\"Bar-\" + index).classList.add(\"comparedElement\");\r\n            }, time * currentSpeed);\r\n        } else {\r\n            // if it is odd, it is the second time we have seen the animation, remove the color from the bar and\r\n            // set it to the appropriate height\r\n            setTimeout(()=> {\r\n                document.getElementById(\"Bar-\" + index).classList.remove(\"comparedElement\");\r\n                document.getElementById(\"Bar-\" + index).style.height = height * 8 + \"px\";\r\n            }, time * currentSpeed);\r\n        }\r\n    };\r\n\r\n    // animate the radix sort algorithm\r\n    animateRadixSort(animations,currentSpeed) {\r\n        // get the number of animations\r\n        let length = animations.length;\r\n        for(let i = 0; i <= length; i++) {\r\n            // if we have reached the end of the animations, display the ending animation\r\n            if(i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, i * currentSpeed)\r\n            } else {\r\n                // get the current animation\r\n                let currentAnimation = animations[i];\r\n                // if it an even index, it is the first time we have seen the animation, color the bar in appopriately\r\n                if(i % 2 === 0) {\r\n                    setTimeout(()=> {\r\n                        document.getElementById(\"Bar-\" + currentAnimation.index).classList.add(\"comparedElement\");\r\n                    }, i * currentSpeed);\r\n                } else {\r\n                    // take color out of bar and set its height appropriately\r\n                    setTimeout(()=> {\r\n                        document.getElementById(\"Bar-\" + currentAnimation.index).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + currentAnimation.index).style.height = currentAnimation.height * 8 + \"px\";\r\n                    }, i * currentSpeed)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // animate the shell sort algorithm\r\n    animateShellSort(animations,currentSpeed) {\r\n        let length = animations.length;\r\n        for(let i = 0;i <= length; i++) {\r\n            // if we have reached the end of the animations, display the ending animation\r\n            if(i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, i * currentSpeed)\r\n            } else {\r\n                let currentAnimation = animations[i];\r\n                // if the index is even, it is the first time we have seen the animation, color in the\r\n                // bars being compared\r\n                if(i % 2 === 0) {\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + currentAnimation.firstElement).classList.add(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + currentAnimation.secondElement).classList.add(\"comparedElement\");\r\n                    }, i * currentSpeed)\r\n                } else {\r\n                    // take colors out of bars and set the height of bar appropriately\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + currentAnimation.firstElement).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + currentAnimation.secondElement).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + currentAnimation.firstElement).style.height = currentAnimation.secondElementHeight * 8 + \"px\";\r\n                    }, i * currentSpeed)\r\n                }    \r\n            }\r\n        }\r\n    };\r\n\r\n    // animate the insertion sort algorithm\r\n    animateInsertionSort(animations,currentSpeed) {\r\n        let length = animations.length;\r\n        for(let i = 0; i <= length; i++) {\r\n            // if we have reached the end of the animations, display the ending animation\r\n            if(i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone()\r\n                }, i * currentSpeed)\r\n            } else {\r\n                let currentAnimation = animations[i];\r\n                // if the index is even, it is the first time we have seen the animation, color in the\r\n                // bars being compared\r\n                if(i % 2 === 0) {\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + currentAnimation.firstElement).classList.add(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + currentAnimation.secondElement).classList.add(\"comparedElement\");\r\n                    }, i * currentSpeed);\r\n                } \r\n                else {\r\n                    if(!currentAnimation.swap) {\r\n                        // if the bars have not been swapped, remove the color\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + currentAnimation.firstElement).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + currentAnimation.secondElement).classList.remove(\"comparedElement\");\r\n                        }, (i * currentSpeed))\r\n                    } else {\r\n                        // if bars have been swapped, take colors out of bars and set the height of bars appropriately\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + currentAnimation.firstElement).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + currentAnimation.secondElement).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + currentAnimation.firstElement).style.height = currentAnimation.secondElementHeight * 8 + \"px\";\r\n                            document.getElementById(\"Bar-\" + currentAnimation.secondElement).style.height = currentAnimation.firstElementHeight * 8 + \"px\";\r\n                        }, (i * currentSpeed))\r\n                    }\r\n                }\r\n            }\r\n            \r\n        }\r\n    };\r\n\r\n    // animate the bubble sort algorithm\r\n    animateBubbleSort(animations, currentSpeed) {\r\n        let length = animations.length;\r\n        for (let i = 0; i <= length; i++) {\r\n            // display ending animation\r\n            if (i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, i * currentSpeed)\r\n            } else {\r\n                let current = animations[i];\r\n                // add color to the two bars being compared\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + current.first).classList.add(\"comparedElement\");\r\n                    document.getElementById(\"Bar-\" + current.second).classList.add(\"comparedElement\");\r\n                }, i * currentSpeed);\r\n                if (!current.swap) {\r\n                    // if they are not swapped, remove color\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + current.first).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.second).classList.remove(\"comparedElement\");\r\n                    }, (i + 1) * currentSpeed);\r\n                } else {\r\n                    // if they are swapped, remove color and swap their heights\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + current.first).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.second).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.first).style.height = current.secondHeight * 8 + \"px\";\r\n                        document.getElementById(\"Bar-\" + current.second).style.height = current.firstHeight * 8 + \"px\";\r\n                    }, ((i + 1) * currentSpeed));\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // animate the bucket sort algorithm\r\n    animateBucketSort(animations, currentSpeed) {\r\n        // the original array\r\n        let original = animations[0];\r\n        // the array after being grouped into buckets\r\n        let grouped = animations[1];\r\n        // iterate through the original array\r\n        for (let j = 0; j < original.length; j++) {\r\n            setTimeout(() => {\r\n                document.getElementById(\"Bar-\" + j).classList.add(\"comparedElement\");\r\n            }, j * currentSpeed);\r\n            setTimeout(() => {\r\n                document.getElementById(\"Bar-\" + j).classList.remove(\"comparedElement\");\r\n            }, (j + 1) * currentSpeed);\r\n        }\r\n        // group the array into buckets\r\n        setTimeout(() => {\r\n            for (let j = 0; j < grouped.length; j++) {\r\n                // add color\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + j).classList.add(\"comparedElement\");\r\n                }, j * currentSpeed);\r\n                // remove color and change height\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + j).classList.remove(\"comparedElement\");\r\n                    document.getElementById(\"Bar-\" + j).style.height = grouped[j] * 8 + \"px\";\r\n                }, (j + 1) * currentSpeed);\r\n            }\r\n        }, original.length * currentSpeed);\r\n        // insertion sort the grouped array\r\n        setTimeout(() => {\r\n            this.animateInsertionSort(insertionSort(grouped), currentSpeed);\r\n        }, original.length * 2 * currentSpeed);\r\n    };\r\n\r\n    // animate the heap sort algorithm\r\n    animateHeapSort(animations, currentSpeed) {\r\n        let length = animations.length;\r\n        for (let i = 0; i <= length; i++) {\r\n            // display ending animation\r\n            if (i === length) {\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, i * currentSpeed);\r\n            } else {\r\n                let current = animations[i];\r\n                if (current.maxHeap) {\r\n                    // building a max heap\r\n                    // add color to the parent and children elements\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + current.parent).classList.add(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.left).classList.add(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.right).classList.add(\"comparedElement\");\r\n                    }, i * currentSpeed);\r\n                    if (current.swapped) {\r\n                        // if two elements need to be swapped, remove color and swap the two elements\r\n                        if (current.swappedLeft) {\r\n                            // swap parent with left child\r\n                            setTimeout(() => {\r\n                                document.getElementById(\"Bar-\" + current.right).classList.remove(\"comparedElement\");\r\n                                document.getElementById(\"Bar-\" + current.parent).style.height = current.leftHeight * 8 + \"px\";\r\n                                document.getElementById(\"Bar-\" + current.left).style.height = current.parentHeight * 8 + \"px\";\r\n                                document.getElementById(\"Bar-\" + current.parent).classList.remove(\"comparedElement\");\r\n                                document.getElementById(\"Bar-\" + current.left).classList.remove(\"comparedElement\");\r\n                            }, (i + 1) * currentSpeed);\r\n                        } else {\r\n                            // swap parent with right child\r\n                            setTimeout(() => {\r\n                                document.getElementById(\"Bar-\" + current.left).classList.remove(\"comparedElement\");\r\n                                document.getElementById(\"Bar-\" + current.parent).style.height = current.rightHeight * 8 + \"px\";\r\n                                document.getElementById(\"Bar-\" + current.right).style.height = current.parentHeight * 8 + \"px\";\r\n                                document.getElementById(\"Bar-\" + current.parent).classList.remove(\"comparedElement\");\r\n                                document.getElementById(\"Bar-\" + current.right).classList.remove(\"comparedElement\");\r\n                            }, (i + 1) * currentSpeed);\r\n                        }\r\n\r\n                    } else {\r\n                        // if nothing needs to be swapped, remove color\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + current.parent).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + current.left).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + current.right).classList.remove(\"comparedElement\");\r\n                        }, (i + 1) * currentSpeed);\r\n                    }\r\n                } else {\r\n                    // if it is already a max heap, swap first and last elements\r\n                    // add color to first and last elements\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + current.first).classList.add(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.last).classList.add(\"comparedElement\");\r\n                    }, i * currentSpeed);\r\n                    // remove color and swap first and last elements\r\n                    setTimeout(() => {\r\n                        document.getElementById(\"Bar-\" + current.first).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.last).classList.remove(\"comparedElement\");\r\n                        document.getElementById(\"Bar-\" + current.first).style.height = current.lastHeight * 8 + \"px\";\r\n                        document.getElementById(\"Bar-\" + current.last).style.height = current.firstHeight * 8 + \"px\";\r\n                    }, (i + 1) * currentSpeed);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // animate the quick sort algorithm\r\n    animateQuickSort(animations, currentSpeed) {\r\n        let length = animations.length;\r\n        let nextTime = 0;\r\n        for (let i = 0; i <= length; i++) {\r\n            if (i === length) {\r\n                // display ending animation\r\n                setTimeout(() => {\r\n                    this.animationDone();\r\n                }, (i + nextTime) * currentSpeed);\r\n            } else {\r\n                let current = animations[i];\r\n                // move pivot to correct location\r\n                // add color to pivot\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + current.start).classList.add(\"comparedElement\");\r\n                    document.getElementById(\"Bar-\" + current.pivotIndex).classList.add(\"comparedElement\");\r\n                }, (i + nextTime) * currentSpeed);\r\n                // remove color to pivot and swap places with the bar at its correct location\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + current.start).classList.remove(\"comparedElement\");\r\n                    document.getElementById(\"Bar-\" + current.pivotIndex).classList.remove(\"comparedElement\");\r\n                    document.getElementById(\"Bar-\" + current.start).style.height = current.oldPivotIndexValue * 8 + \"px\";\r\n                    document.getElementById(\"Bar-\" + current.pivotIndex).style.height = current.pivot * 8 + \"px\";\r\n                }, (i + nextTime + 1) * currentSpeed);\r\n\r\n                // partition the rest of the elements around the pivot\r\n                setTimeout(() => {\r\n                    // move all the elements less than the pivot to the left side\r\n                    let time1 = 0;\r\n                    for (let j = current.start; j < current.pivotIndex; j++) {\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + j).classList.add(\"comparedElement\");\r\n                        }, time1 * currentSpeed);\r\n                        let newHeight = current.lower[j - current.start];\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + j).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + j).style.height = newHeight * 8 + \"px\";\r\n                        }, (time1 + 1) * currentSpeed);\r\n                        time1++;\r\n                    }\r\n                    // move all the elements greater than the pivot to the right side\r\n                    let time2 = 0;\r\n                    for (let j = current.end; j >= current.pivotIndex + 1; j--) {\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + j).classList.add(\"comparedElement\");\r\n                        }, time2 * currentSpeed);\r\n                        let newHeight = current.higher[j - current.pivotIndex - 1];\r\n                        setTimeout(() => {\r\n                            document.getElementById(\"Bar-\" + j).classList.remove(\"comparedElement\");\r\n                            document.getElementById(\"Bar-\" + j).style.height = newHeight * 8 + \"px\";\r\n                        }, (time2 + 1) * currentSpeed);\r\n                        time2++;\r\n                    }\r\n                }, (i + nextTime + 1) * currentSpeed);\r\n                nextTime = 3 + nextTime + Math.max(current.lower.length, current.higher.length);\r\n            }\r\n        }\r\n    };\r\n\r\n    // determines how fast the sorting algorithms are running\r\n    updateSortSpeed = (event) => {\r\n        // fast = 5, medium = 15, slow = 100\r\n        let speed;\r\n        if(event.target.value === \"Slow\") {\r\n            speed = 100;\r\n        } else if(event.target.value === \"Regular\") {\r\n            speed = 15;\r\n        } else {\r\n            speed = 5;\r\n        }\r\n        this.setState({\r\n            sortSpeedSelected: event.target.value,\r\n            currentSpeed: speed\r\n        });\r\n    };\r\n\r\n    // reset all elements to initial state\r\n    reset = () => {\r\n        let elements = this.loadArray(50);\r\n        gridClear = true;\r\n        this.setState({\r\n            numberOfElements: 50,\r\n            elementsToSort: elements,\r\n            currentAlgo: \"Merge Sort\",\r\n            sortSpeedSelected: \"Regular\",\r\n            currentSpeed: 15\r\n        });\r\n    };\r\n\r\n    // this animation happens when algorithms are done\r\n    animationDone() {\r\n        for(let i = 0; i <= this.state.numberOfElements; i++) {\r\n            if(i < this.state.numberOfElements) {\r\n                setTimeout(() => {\r\n                    document.getElementById(\"Bar-\" + i).classList.add(\"doneElement\");\r\n                },i * this.state.currentSpeed);\r\n            } else {\r\n                setTimeout(() => {\r\n                    for(let j = 0; j < this.state.numberOfElements; j++) {\r\n                        document.getElementById(\"Bar-\" + j).classList.remove(\"doneElement\");\r\n                    }\r\n                    this.enableElements();\r\n                },(i * this.state.currentSpeed) + 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    // disable all elements for user interaction\r\n    disableElements() {\r\n        document.getElementById(`sliderNumElements`).setAttribute(\"disabled\",\"disabled\");\r\n        document.getElementById(`buttonRandomize`).setAttribute(\"disabled\",\"disabled\");\r\n        document.getElementById(`sliderAlgo`).setAttribute(\"disabled\",\"disabled\");\r\n        document.getElementById(`sliderAlgoSpeed`).setAttribute(\"disabled\",\"disabled\");\r\n        document.getElementById(`buttonVisualize`).setAttribute(\"disabled\",\"disabled\");\r\n        document.getElementById(`buttonReset`).setAttribute(\"disabled\",\"disabled\");\r\n    }\r\n\r\n    // enable all elements for user interaction\r\n    enableElements() {\r\n        document.getElementById(`sliderNumElements`).removeAttribute(\"disabled\");\r\n        document.getElementById(`buttonRandomize`).removeAttribute(\"disabled\");\r\n        document.getElementById(`sliderAlgo`).removeAttribute(\"disabled\");\r\n        document.getElementById(`sliderAlgoSpeed`).removeAttribute(\"disabled\");\r\n        document.getElementById(`buttonVisualize`).removeAttribute(\"disabled\");\r\n        document.getElementById(`buttonReset`).removeAttribute(\"disabled\");\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"page\">\r\n                <div className=\"top-banner\">\r\n                    <h1 className=\"header\">Sorting algorithm visualizer</h1>\r\n                </div>\r\n                <div className=\"bars\">\r\n                    {this.state.elementsToSort.map((n,index) => {\r\n                        return (\r\n                            <Bar\r\n                            size={n}\r\n                            key={index}\r\n                            index={index}\r\n                            >\r\n                            </Bar>\r\n                        )   \r\n                    })}\r\n                </div>\r\n                <div className=\"footer\">\r\n                    <label className=\"label\">Number of elements:</label>\r\n                    <input id=\"sliderNumElements\" type=\"range\" min=\"2\" max=\"96\" className=\"slider\" value={this.state.numberOfElements}\r\n                           onChange={this.handleNumElementChange}/>\r\n                    <label className=\"minorLabel\">{this.state.numberOfElements}</label>\r\n                    <button id=\"buttonRandomize\" className=\"button\" onClick={this.handleRandomizeClick}>Randomize Elements</button>\r\n                    <label className=\"label\">Sort with: </label>\r\n                    <select id=\"sliderAlgo\" className=\"dropDown\" value={this.state.currentAlgo} onChange={this.updateCurrentAlgo}>\r\n                        {this.state.algorithms.map(algorithms => (\r\n                            <option key={algorithms} value={algorithms}>\r\n                                {algorithms}\r\n                            </option>\r\n                        ))}\r\n                    </select>\r\n                    <label className=\"label\">Sorting speed:</label>\r\n                    <select id=\"sliderAlgoSpeed\" className=\"dropDownSpeed\" value={this.state.sortSpeedSelected} onChange={this.updateSortSpeed}>\r\n                        {this.state.sortSpeed.map(element => (\r\n                            <option key={element} value={element}>\r\n                                {element}\r\n                            </option>\r\n                        ))}\r\n                    </select>\r\n                    <button id=\"buttonVisualize\" className=\"button\" onClick={this.sortElements}>VISUALIZE SORTING</button>\r\n                    <button id=\"buttonReset\" className=\"button\" onClick={this.reset}>Reset</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n  ","/*\r\nBUCKET SORT ALGORITHM.\r\n- best case: O(n+k)\r\n- worst case: O(n^2)\r\n- average: O(n+k)\r\nSeparate the elements of the array into \"buckets\" that hold a specific range\r\nof values. Individually sort the buckets using insertion sort, then recombine them.\r\n */\r\n\r\nimport {insertionSort} from './InsertionSort';\r\n\r\nexport function bucketSort(arr) {\r\n    let animations = [];\r\n    // make a copy of original array (for animation purposes)\r\n    let originalArr = arr.slice();\r\n    animations.push(originalArr);\r\n\r\n    // default bucket size\r\n    const BUCKET_SIZE = 5;\r\n    // find min and max values in array\r\n    let min = arr[0];\r\n    let max = arr[0];\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] < min) {\r\n            min = arr[i];\r\n        }\r\n        if (arr[i] > max) {\r\n            max = arr[i];\r\n        }\r\n    }\r\n    // create buckets of size 5\r\n    let range = max - min;\r\n    let buckets = [];\r\n    for (let i = 0; i <= Math.floor(range / BUCKET_SIZE); i++) {\r\n        buckets.push([]);\r\n    }\r\n    // add values to buckets\r\n    for (let value of arr) {\r\n        buckets[Math.floor((value - min) / BUCKET_SIZE)].push(value);\r\n    }\r\n\r\n    // group the buckets together in order (for animation purposes)\r\n    let groupedArr = [];\r\n    for (let bucket of buckets) {\r\n        groupedArr = groupedArr.concat(bucket);\r\n    }\r\n    animations.push(groupedArr);\r\n\r\n    // sort each bucket and recombine them\r\n    arr = [];\r\n    for (let bucket of buckets) {\r\n        if (bucket.length > 1) {\r\n            insertionSort(bucket);\r\n        }\r\n        if (bucket.length > 0) {\r\n            arr = arr.concat(bucket);\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n","// radix sort sorts the array based on the value of each digit in each index of the array. It uses counting sort\r\n// to do this, stopping when it reaches the number of digits in the largest array\r\n\r\n// radix sort\r\nexport function radixSort(arr) {\r\n    // get the maximum number of digits\r\n    let maxNum = getMax(arr);\r\n\r\n    let positions = [];\r\n\r\n    // for every digit:\r\n    // note: Radix sort works because the elements in the original array are changing every \r\n    //       iteration. This, combined with the fact that counting sort is stable, results in the correct\r\n    //       ending array\r\n    for (let i = 0; i < maxNum; i++) {\r\n        // create 10 empty arrays\r\n        let buckets = Array.from({length: 10}, () => []);\r\n\r\n        // tracks the new index of every element\r\n        let newIndexes = [];\r\n\r\n        // for every number in the array:\r\n        for (let j = 0; j < arr.length; j++) {\r\n            let newPosition = {\r\n                height: arr[j],\r\n                index: j,\r\n                row: null,\r\n                col: null\r\n            };\r\n            positions.push(newPosition);\r\n            positions.push(newPosition);\r\n            // get the digit at the ith place in every element\r\n            let position = getPosition(arr[j], i);\r\n\r\n            // push the new position of the first element so that\r\n            // it can be animated first (animation will look cooler)\r\n\r\n            // at this point, we dont know what the actual index of this element is,\r\n            // we will need to calculate it after the loop terminates\r\n            let newIndex = {\r\n                height: arr[j],\r\n                index: undefined,\r\n                row: position,\r\n                col: buckets[position].length\r\n            };\r\n            newIndexes.push(newIndex);\r\n\r\n            // push the element into the correct spot in the 10 arrays stored in bucket\r\n            buckets[position].push(arr[j]);\r\n        }\r\n\r\n        // calculate how many elements come before the position of an index\r\n        for(let i = 0; i < newIndexes.length; i++) {\r\n            let currentIndex = newIndexes[i];\r\n            let newIndex = 0;\r\n            for(let j = 0; j <= currentIndex.row; j++) {\r\n                for(let z = 0; z < buckets[j].length; z++) {\r\n                    if(j === currentIndex.row && z === currentIndex.col) {\r\n                        break;\r\n                    }\r\n                    newIndex++;\r\n                }\r\n            }\r\n            currentIndex.index = newIndex;\r\n        }\r\n\r\n        // push the elements in newIndexes to be displated in the positions array\r\n        for(let i = 0; i < newIndexes.length; i++) {\r\n            // push animation twice (we need to display color and then remove color)\r\n            positions.push(newIndexes[i]);\r\n            positions.push(newIndexes[i]);\r\n        }\r\n\r\n        // set array equal to the non empty elements in buckets in the order they appear\r\n        arr = [].concat(...buckets);\r\n    }\r\n    return positions;\r\n}\r\n\r\n// get the maximum number of digits in a number\r\nfunction getMax(arr) {\r\n    let max = 0;\r\n    for (let i = 0; i <arr.length;i++) {\r\n        let num = arr[i];\r\n        if (max < num.toString().length) {\r\n            max = num.toString().length\r\n        }\r\n    }\r\n    return max\r\n}\r\n\r\n// get the digit at a position in a number ( getPosition(231,1) = 3)\r\nfunction getPosition(num, place){\r\n    return Math.floor(Math.abs(num)/Math.pow(10,place)) % 10;\r\n}","// shell sort is an extended version of insertion sort, where a particular\r\n// element in an array is not being compared to the elements next to it but a certain\r\n// gap distance away\r\n\r\nexport function shellSort(arr) {\r\n    // if there is only one element, the array is sorted\r\n    if(arr.length === 1) {\r\n        return arr;\r\n    }\r\n\r\n    // animations to be returned\r\n    let animations = [];\r\n\r\n    // get the length of the array\r\n    let length = arr.length;\r\n    // the gap is first set to half the length of the array\r\n    let gap = Math.floor(length/2);\r\n\r\n    // while the gap is not zero\r\n    while(gap > 0) {\r\n        // go through every element starting at the gap index\r\n        for(let i = gap; i < arr.length; i++) {\r\n            // temp variable that is swapped later\r\n            let temp = arr[i];\r\n            // refers to the index of element swapped\r\n            let last = i;\r\n\r\n            // if the element to the left of j that is gap distance away is greater than the current element\r\n            for(let j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\r\n                let comparedElements = {\r\n                    firstElement: j,\r\n                    secondElement: j-gap,\r\n                    secondElementHeight: arr[j - gap],\r\n                    firstElementHeight: arr[j]\r\n                }\r\n                animations.push(comparedElements);\r\n                animations.push(comparedElements);\r\n                // set the jth element to be the j - gap element\r\n                arr[j] = arr[j - gap];\r\n                last -= gap;\r\n            }\r\n            let comparedElements = {\r\n                firstElement: last,\r\n                secondElement: i,\r\n                secondElementHeight: temp,\r\n                firstElementHeight: arr[last]\r\n            }\r\n            // push animation twice (we need to display color and then remove color)\r\n            animations.push(comparedElements);\r\n            animations.push(comparedElements);\r\n            arr[last] = temp;\r\n        }\r\n        // gap is cut in half each time (eventually becoming insertion sort when it is 1)\r\n        gap = Math.floor(gap/2);\r\n    }\r\n\r\n    return animations;\r\n}","import React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport SortingMain from './SortingVisual/SortingMain';\r\n\r\nfunction App() {\r\n  return (\r\n    <SortingMain></SortingMain>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}